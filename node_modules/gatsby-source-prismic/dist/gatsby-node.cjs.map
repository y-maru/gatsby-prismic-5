{"version":3,"file":"gatsby-node.cjs","sources":["../src/lib/getTypeName.ts","../src/lib/buildUnionType.ts","../src/lib/createType.ts","../src/lib/createAllDocumentTypesType.ts","../src/constants.ts","../src/lib/buildObjectType.ts","../src/lib/mapRecordIndices.ts","../src/builders/buildBooleanFieldConfig.ts","../src/builders/buildColorFieldConfig.ts","../src/builders/buildDateFieldConfig.ts","../src/builders/buildEmbedFieldConfig.ts","../src/builders/buildGeoPointFieldConfig.ts","../src/lib/listTypeName.ts","../src/lib/buildSchemaRecordType.ts","../src/builders/buildGroupFieldConfig.ts","../src/lib/sanitizeImageURL.ts","../src/lib/stripURLParameters.ts","../src/builders/buildImageBaseFieldConfigMap.ts","../src/builders/buildImageFieldConfig.ts","../src/builders/buildLinkFieldConfig.ts","../src/builders/buildNumberFieldConfig.ts","../src/builders/buildSelectFieldConfig.ts","../src/builders/buildStructuredTextFieldConfig.ts","../src/lib/createTypes.ts","../src/lib/requiredTypeName.ts","../src/builders/buildSlicesFieldConfig.ts","../src/builders/buildTextFieldConfig.ts","../src/builders/buildTimestampFieldConfig.ts","../src/builders/buildUIDFieldConfig.ts","../src/lib/dotPath.ts","../src/lib/sprintf.ts","../src/lib/reportInfo.ts","../src/builders/buildUnknownFieldConfig.ts","../src/lib/buildNamedInferredNodeType.ts","../src/lib/buildInferredNodeType.ts","../src/builders/buildIntegrationFieldConfig.ts","../src/lib/toFieldConfig.ts","../src/lib/buildFieldConfigMap.ts","../src/lib/createCustomType.ts","../src/builders/buildSharedSliceVariationTypes.ts","../src/lib/createSharedSlice.ts","../src/lib/createNodeOfType.ts","../src/lib/createTypePath.ts","../src/lib/preparePluginOptions.ts","../src/lib/throwError.ts","../src/builders/buildAlternateLanguageType.ts","../src/builders/buildEmbedType.ts","../src/builders/buildGeoPointType.ts","../src/builders/buildImageDimensionsType.ts","../src/builders/buildImageThumbnailType.ts","../src/builders/buildImgixImageTypes.ts","../src/builders/buildLinkType.ts","../src/lib/buildEnumType.ts","../src/builders/buildLinkTypeEnumType.ts","../src/lib/buildInterfaceType.ts","../src/builders/buildSharedSliceInterface.ts","../src/builders/buildSliceInterface.ts","../src/lib/buildScalarType.ts","../src/builders/buildStructuredTextType.ts","../src/builders/buildTypePathType.ts","../src/types.ts","../src/runtime/createGetProxy.ts","../src/runtime/normalizers/alternateLanguages.ts","../src/runtime/normalizers/document.ts","../src/runtime/normalizers/documentData.ts","../src/runtime/normalizers/group.ts","../src/runtime/normalizers/image.ts","../src/runtime/normalizers/link.ts","../src/runtime/normalizers/structuredText.ts","../src/runtime/normalizers/slice.ts","../src/runtime/normalizers/slices.ts","../src/runtime/normalize.ts","../src/runtime/typePaths.ts","../src/runtime/serializePath.ts","../src/runtime/serializeTypePaths.ts","../src/runtime/runtime.ts","../src/buildDependencies.ts","../src/create-schema-customization.ts","../src/plugin-options-schema.ts","../src/lib/createGloballyUniqueNodeOfType.ts","../src/lib/createGloballyUniqueNode.ts","../src/lib/createGloballyUniqueNodes.ts","../src/lib/getTypePath.ts","../src/lib/shouldDownloadFile.ts","../src/lib/getFromCache.ts","../src/lib/setToCache.ts","../src/lib/getFromOrSetToCache.ts","../src/lib/touchNode.ts","../src/lib/reportVerbose.ts","../src/lib/createRemoteFileNode.ts","../src/lib/removeAutoURLParameter.ts","../src/lib/normalizeDocumentSubtree.ts","../src/lib/normalizeDocument.ts","../src/lib/normalizeDocuments.ts","../src/lib/queryAllDocuments.ts","../src/lib/sourceNodesForAllDocuments.ts","../src/lib/isPrismicURL.ts","../src/lib/isPrismicWebhookBody.ts","../src/lib/isPrismicWebhookBodyApiUpdate.ts","../src/lib/isPrismicWebhookBodyForRepository.ts","../src/lib/isPrismicWebhookBodyTestTrigger.ts","../src/lib/isValidWebhookSecret.ts","../src/lib/reportWarning.ts","../src/lib/getNode.ts","../src/lib/getNodes.ts","../src/lib/deleteNode.ts","../src/lib/deleteNodes.ts","../src/lib/deleteNodesForDocumentIds.ts","../src/lib/queryDocumentsByIds.ts","../src/lib/sourceNodesForDocumentIds.ts","../src/lib/getAllNodes.ts","../src/lib/touchNodes.ts","../src/lib/touchAllNodes.ts","../src/on-webhook-api-update.ts","../src/on-webhook-test-trigger.ts","../src/on-webhook.ts","../src/source-nodes.ts"],"sourcesContent":["import * as gatsby from \"gatsby\";\n\n/**\n * Returns the name of a GraphQL object type created by `graphql-compose`.\n *\n * @param type - GraphQL object type created by `graphql-compose`.\n *\n * @returns Name of the type.\n */\nexport const getTypeName = (type: gatsby.GatsbyGraphQLType): string =>\n\ttype.config.name;\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL union type using the environment's `buildUnionType` function.\n *\n * @param config - Configuration for the union type.\n *\n * @returns Return value of the environment's `buildUnionType` function.\n */\nexport const buildUnionType = <TSource, TContext>(\n\tconfig: gqlc.UnionTypeComposerAsObjectDefinition<TSource, TContext>,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLUnionType> =>\n\tRTE.asks((deps) => deps.buildUnionType(config));\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Registers a type using the environment's `createTypes` function.\n *\n * @param type - GraphQL type to create.\n */\nexport const createType = <A extends gatsby.GatsbyGraphQLType>(\n\ttype: A,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) => deps.createTypes(type));\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { getTypeName } from \"./getTypeName\";\nimport { buildUnionType } from \"./buildUnionType\";\nimport { createType } from \"./createType\";\n\n/**\n * Registers the `AllDocumentTypes` GraphQL union type containing all provided\n * document types.\n *\n * @param types - List of document types to include in the created union type.\n *\n * @returns The registered `AllDocumentTypes` type.\n */\nexport const createAllDocumentTypesType = (\n\ttypes: gatsby.GatsbyGraphQLObjectType[],\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLUnionType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\ttypes,\n\t\t\t\tA.map(getTypeName),\n\t\t\t\t(types) =>\n\t\t\t\t\tbuildUnionType({\n\t\t\t\t\t\tname: deps.nodeHelpers.createTypeName(\"AllDocumentTypes\"),\n\t\t\t\t\t\ttypes,\n\t\t\t\t\t}),\n\t\t\t\tRTE.chainFirst(createType),\n\t\t\t),\n\t\t),\n\t);\n","/**\n * Name of the plugin used to identify Nodes owned by this plugin.\n *\n * Note: This should always be in sync with package.json's `name` field.\n */\nexport const PLUGIN_NAME = \"gatsby-source-prismic\";\n\n/**\n * Global prefix used for all GraphQL types and, where necessary, fields.\n */\nexport const GLOBAL_TYPE_PREFIX = \"Prismic\";\n\n/**\n * Default endpoint used to fetch custom type JSON schemas from Prismic's Custom Type API.\n *\n * @see https://prismic.io/docs/technologies/custom-types-api\n */\nexport const DEFAULT_CUSTOM_TYPES_API_ENDPOINT =\n\t\"https://customtypes.prismic.io/customtypes\";\n\n/**\n * Prismic API document fields returned for image fields that are **not** thumbnails.\n *\n * These fields are filtered out from the API response to extract the field's\n * thumbnails. The API includes thumbnails adjacent to these fields.\n */\nexport const PRISMIC_API_IMAGE_FIELDS = [\n\t\"alt\",\n\t\"copyright\",\n\t\"dimensions\",\n\t\"url\",\n];\n\n/**\n * Default Imgix URL parameters for `gatsby-plugin-image` fields.\n *\n * These defaults provide a good balance between image quality and filesize.\n *\n * @see https://docs.imgix.com/apis/rendering\n */\nexport const DEFAULT_IMGIX_PARAMS = {\n\tauto: \"compress,format\",\n\n\t// The following values are not included by Prismic's URLs by default.\n\tfit: \"max\",\n} as const;\n\n/**\n * Default Imgix URL parameters for `gatsby-plugin-image` placeholder images.\n *\n * These defaults provide a good balance between image quality and filesize.\n * They are merged with the `imageImgixParams` plugin option.\n *\n * @see https://docs.imgix.com/apis/rendering\n */\nexport const DEFAULT_PLACEHOLDER_IMGIX_PARAMS = {\n\tw: 100,\n\n\t// Makes the image appear less pixelated when stretched to large sizes.\n\t//\n\t// TODO: This value can be removed if `gatsby-plugin-image` implements\n\t// CSS-based blurring.\n\tblur: 15,\n} as const;\n\n/**\n * Default Prismic language option used when fetching documents. The current\n * default fetches all languages.\n *\n * @see https://prismic.io/docs/technologies/query-by-language-rest-api\n */\nexport const DEFAULT_LANG = \"*\";\n\n/**\n * Format used for all plugin reporting. Includes the plugin's name and the\n * instance's repository name (helpful when multiple repositories are configured).\n */\nexport const REPORTER_TEMPLATE = `gatsby-source-prismic(%s) - %s`;\n\n/**\n * Root node field used to compare static data with preview data. If values are\n * equal, the preview node can be treated as an updated version of the static node.\n *\n * This is an internal-use-only field used by `gatsby-plugin-prismic-previews`.\n */\nexport const PREVIEWABLE_NODE_ID_FIELD = \"_previewable\";\n\n/**\n * Message displayed to the user when a webhook's secret does not match the\n * secret configured in the site's `gatsby-config.js`.\n */\nexport const WEBHOOK_SECRET_MISMATCH_MSG =\n\t\"A webhook was received, but the webhook secret did not match the webhook secret provided in the plugin options. If this is unexpected, verify that the `webhookSecret` plugin option matches the webhook secret in your Prismic repository.\";\n\n/**\n * Message displayed to the user when a `test-trigger` webhook is received.\n */\nexport const WEBHOOK_TEST_TRIGGER_SUCCESS_MSG =\n\t\"Success! Received a test trigger webhook. When changes to your content are saved, Gatsby will automatically fetch the changes.\";\n\n/**\n * Message displayed to the user when a missing custom type schema is detected.\n */\nexport const MISSING_SCHEMAS_MSG =\n\t\"JSON schemas for all custom types are required\";\n\n/**\n * Format used to inform the user of a missing schema.\n */\nexport const MISSING_SCHEMA_MSG =\n\t'JSON model for \"%s\" is missing. If the Custom Type is no longer in use, you may provide \"{}\" as the JSON model.';\n\nexport const FORBIDDEN_ACCESS_WITHOUT_ACCESS_TOKEN =\n\t\"Unable to access the Prismic repository. Check the repository name. If the repository is secured, provide an access token.\";\n\nexport const FORBIDDEN_ACCESS_WITH_ACCESS_TOKEN =\n\t\"Unable to access the Prismic repository. Check that the correct repository name and access token are provided.\";\n\nexport const FORBIDDEN_CUSTOM_TYPES_API_ACCESS =\n\t\"Unable to access the Prismic Custom Types API. Check the customTypesApiToken option.\";\n\nexport const NON_EXISTENT_RELEASE_WITH_ACCESS_TOKEN_MSG =\n\t'The given Release ID (\"%s\") could not be found. If the Release ID is correct, check that your access token has permission to view Releases.';\n\nexport const NON_EXISTENT_RELEASE_WITHOUT_ACCESS_TOKEN_MSG =\n\t'The given Release ID (\"%s\") could not be found. If the Release ID is correct, you may need to provide an access token with permission to view Releases.';\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL object type using the environment's `buildObjectType` function.\n *\n * @param config - Configuration for the object type.\n *\n * @returns Return value of the environment's `buildObjectType` function.\n */\nexport const buildObjectType = <TSource, TContext>(\n\tconfig: gqlc.ObjectTypeComposerAsObjectDefinition<TSource, TContext>,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLObjectType> =>\n\tRTE.asks((deps) => deps.buildObjectType(config));\n","import * as R from \"fp-ts/Record\";\nimport * as A from \"fp-ts/Array\";\nimport * as S from \"fp-ts/Semigroup\";\nimport { flow } from \"fp-ts/function\";\n\n/**\n * Maps indices of a record with a given function.\n *\n * @param f - Function mapping an index to a new index.\n *\n * @returns A function that accepts a record to be updated.\n */\nexport const mapRecordIndices = <K extends string, A>(\n\tf: (k: K) => string,\n): ((r: Record<K, A>) => Record<string, A>) =>\n\tflow(\n\t\tR.collect((index: K, value) => [f(index), value] as [string, A]),\n\t\tR.fromFoldable(S.last<A>(), A.Foldable),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Boolean Custom Type field.\n * The resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildBooleanFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"Boolean\");\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Color Custom Type field.\n * The resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildColorFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"String\");\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Date Custom Type field. It\n * includes Gatsby's `@dateformat` extension. The resulting configuration object\n * can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildDateFieldConfig: FieldConfigCreator = () =>\n\tRTE.right({\n\t\ttype: \"Date\",\n\t\textensions: { dateformat: {} },\n\t});\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for an Embed Custom Type field.\n * It uses a shared type and the `@link` extension to connect data to the field.\n * Data for each Embed field is created as a separate node to allow Gatsby to\n * infer the fields and types. The resulting configuration object can be used in\n * a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildEmbedFieldConfig: FieldConfigCreator = () =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.map((deps) => ({\n\t\t\ttype: deps.nodeHelpers.createTypeName(\"EmbedType\"),\n\t\t\textensions: { link: {} },\n\t\t})),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a GeoPoint Custom Type field.\n * The resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildGeoPointFieldConfig: FieldConfigCreator = () =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.map((deps) => deps.globalNodeHelpers.createTypeName(\"GeoPointType\")),\n\t);\n","/**\n * Converts a given GraphQL type name to a list type.\n *\n * @example\n *\n * ```ts\n * listTypeName(\"MyType\"); // => \"[MyType]\"\n * ```\n *\n * @param typeName - Type name to convert.\n *\n * @returns Type name wrapped as a list type.\n */\nexport const listTypeName = (typeName: string): string => `[${typeName}]`;\n","import * as gatsby from \"gatsby\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildObjectType } from \"./buildObjectType\";\nimport { buildFieldConfigMap } from \"./buildFieldConfigMap\";\n\n/**\n * Builds a GraphQL type from a record mapping a Prismic field API ID to its\n * schema definition.\n *\n * @param path - Path to the schema record.\n * @param record - Record mapping a Prismic field API ID to its schema definition.\n * @param typeName - Type name of the resulting GraphQL type.\n *\n * @returns GraphQL type containing fields for each record property.\n */\nexport const buildSchemaRecordType = (\n\tpath: string[],\n\trecord: Record<string, prismicT.CustomTypeModelField>,\n\ttypeName: string | string[] = path,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsby.GatsbyGraphQLObjectType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"fields\", () => buildFieldConfigMap(path, record)),\n\t\tRTE.chainW((scope) =>\n\t\t\tbuildObjectType({\n\t\t\t\tname: scope.nodeHelpers.createTypeName(typeName),\n\t\t\t\tfields: scope.fields,\n\t\t\t}),\n\t\t),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { createType } from \"../lib/createType\";\nimport { getTypeName } from \"../lib/getTypeName\";\nimport { listTypeName } from \"../lib/listTypeName\";\nimport { buildSchemaRecordType } from \"../lib/buildSchemaRecordType\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Group Custom Type field. It\n * creates a GraphQL List type using the Group field's individual fields. Each\n * field is converted to their own GraphQL configuration object.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildGroupFieldConfig: FieldConfigCreator<prismicT.CustomTypeModelGroupField> =\n\t(path, schema) =>\n\t\tpipe(\n\t\t\tRTE.ask<Dependencies>(),\n\t\t\tRTE.chain(() => buildSchemaRecordType(path, schema.config.fields)),\n\t\t\tRTE.chainFirstW(createType),\n\t\t\tRTE.map(getTypeName),\n\t\t\tRTE.map(listTypeName),\n\t\t);\n","/**\n * Sanitizes an image URL. The following steps are taken:\n *\n * - Replace `+` in filename with a space\n * - Decode the URL\n *\n * @param url - Image URL to sanitize.\n *\n * @returns Sanitized image URL.\n */\n// TODO: Remove once the Prismic API properly handles spaces in filenames\nexport const sanitizeImageURL = (url: string): string =>\n\tdecodeURIComponent(url.replace(/\\+/g, \" \"));\n","import * as O from \"fp-ts/Option\";\nimport { pipe } from \"fp-ts/function\";\n\n/**\n * Removes query parameters from a URL. If the URL is invalid, the input is\n * returned as is.\n *\n * @param url - URL from which to remove query parameters.\n *\n * @returns `url` without query parameters.\n */\nexport const stripURLQueryParameters = (url: string): string =>\n\tpipe(\n\t\tO.tryCatch(() => new URL(url)),\n\t\tO.map((instance) => `${instance.origin}${instance.pathname}`),\n\t\tO.getOrElse(() => url),\n\t);\n","import * as gqlc from \"graphql-compose\";\nimport * as imgixGatsby from \"@imgix/gatsby/dist/pluginHelpers\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as O from \"fp-ts/Option\";\nimport * as S from \"fp-ts/Semigroup\";\nimport * as A from \"fp-ts/Array\";\nimport * as R from \"fp-ts/Record\";\nimport { constNull, pipe } from \"fp-ts/function\";\n\nimport { sanitizeImageURL } from \"../lib/sanitizeImageURL\";\nimport { stripURLQueryParameters } from \"../lib/stripURLParameters\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Returns the URL of an image from the value of an Image field.\n *\n * @param source - Image field data.\n *\n * @returns The URL of the image if an image is provided, `null` otherwise.\n */\nconst resolveUrl = (source: prismicT.ImageField): string | null =>\n\tsource.url\n\t\t? sanitizeImageURL(stripURLQueryParameters(source.url))\n\t\t: source.url ?? null;\n\n/**\n * Returns the width of an image from the value of an Image field.\n *\n * @param source - Image field data.\n *\n * @returns The width of the image if an image is provided, `undefined` otherwise.\n */\nconst resolveWidth = (source: prismicT.ImageField): number | undefined =>\n\tsource.dimensions?.width;\n\n/**\n * Returns the height of an image from the value of an Image field.\n *\n * @param source - Image field data.\n *\n * @returns The height of the image if an image is provided, `undefined` otherwise.\n */\nconst resolveHeight = (source: prismicT.ImageField): number | undefined =>\n\tsource.dimensions?.height;\n\n/**\n * The minimum required GraphQL argument properties for an `@imgix/gatsby` field.\n */\ninterface ImgixGatsbyFieldArgsLike {\n\timgixParams: Record<string, string | number | boolean>;\n}\n\n/**\n * Modifies an `@imgix/gatsby` GraphQL field config to retain existing Imgix\n * parameters set on the source URL.\n *\n * This is needed if the source URL contains parameters like `rect` (crops an\n * image). Without this config enhancer, the `rect` parameter would be removed.\n *\n * @param fieldConfig - GraphQL field config object to be enhanced.\n *\n * @returns `fieldConfig` with the ability to retain existing Imgix parameters\n *   on the source URL.\n */\nconst withExistingURLImgixParameters = <\n\tTContext,\n\tTArgs extends ImgixGatsbyFieldArgsLike,\n>(\n\tfieldConfig: gqlc.ObjectTypeComposerFieldConfigAsObjectDefinition<\n\t\tprismicT.ImageField,\n\t\tTContext,\n\t\tTArgs\n\t>,\n): typeof fieldConfig => ({\n\t...fieldConfig,\n\tresolve: (source, args, ...rest) =>\n\t\tpipe(\n\t\t\tO.Do,\n\t\t\tO.bind(\"url\", () =>\n\t\t\t\tO.fromNullable(source.url ? new URL(source.url) : null),\n\t\t\t),\n\t\t\tO.bind(\"existingImgixParams\", (scope) =>\n\t\t\t\tpipe(\n\t\t\t\t\t[...scope.url.searchParams.entries()],\n\t\t\t\t\tR.fromFoldable(S.last<string>(), A.Foldable),\n\t\t\t\t\tO.of,\n\t\t\t\t),\n\t\t\t),\n\t\t\tO.map((scope) =>\n\t\t\t\tfieldConfig.resolve?.(\n\t\t\t\t\tsource,\n\t\t\t\t\t{\n\t\t\t\t\t\t...args,\n\t\t\t\t\t\timgixParams: {\n\t\t\t\t\t\t\t...scope.existingImgixParams,\n\t\t\t\t\t\t\t...args.imgixParams,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t...rest,\n\t\t\t\t),\n\t\t\t),\n\t\t\tO.getOrElseW(constNull),\n\t\t),\n});\n\n/**\n * Builds a GraphQL field configuration object to be used as part of another\n * Image field GraphQL configuration object. For example, this base\n * configuration object could be added to a config for the thumbnails of an Image field.\n */\nexport const buildImageBaseFieldConfigMap: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgqlc.ObjectTypeComposerFieldConfigMapDefinition<prismicT.ImageField, unknown>\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.bind(\"imgixTypes\", (scope) =>\n\t\tRTE.right(\n\t\t\timgixGatsby.createImgixGatsbyTypes({\n\t\t\t\t// IMPORTANT: These options need to be kept in sync with the options at\n\t\t\t\t// packages/gatsby-source-prismic/src/builders/buildImgixImageTypes.ts\n\t\t\t\tcache: scope.cache,\n\t\t\t\tresolveUrl,\n\t\t\t\tresolveWidth,\n\t\t\t\tresolveHeight,\n\t\t\t\tdefaultParams: scope.pluginOptions.imageImgixParams,\n\t\t\t\tnamespace: \"Imgix\",\n\t\t\t}),\n\t\t),\n\t),\n\tRTE.bind(\"urlField\", (scope) =>\n\t\tRTE.right(withExistingURLImgixParameters(scope.imgixTypes.fields.url)),\n\t),\n\tRTE.bind(\"fixedField\", (scope) =>\n\t\tRTE.right(withExistingURLImgixParameters(scope.imgixTypes.fields.fixed)),\n\t),\n\tRTE.bind(\"fluidField\", (scope) =>\n\t\tRTE.right(withExistingURLImgixParameters(scope.imgixTypes.fields.fluid)),\n\t),\n\tRTE.bind(\"gatsbyImageDataField\", (scope) =>\n\t\tpipe(\n\t\t\tRTE.right(\n\t\t\t\twithExistingURLImgixParameters(scope.imgixTypes.fields.gatsbyImageData),\n\t\t\t),\n\t\t\t// This field is 'JSON!' by default (i.e. non-nullable). If an image is\n\t\t\t// not set in Prismic, however, this field throws a GraphQL error saying a\n\t\t\t// non-nullable field was returned a null value. This should not happen\n\t\t\t// since the field is nested in a nullable object type, but it happens\n\t\t\t// anyway.\n\t\t\t//\n\t\t\t// We're making the field nullable manually here.\n\t\t\tRTE.chainFirst((field) => RTE.fromIO(() => (field.type = \"JSON\"))),\n\t\t),\n\t),\n\tRTE.map((scope) => ({\n\t\talt: \"String\",\n\t\tcopyright: \"String\",\n\t\tdimensions: scope.globalNodeHelpers.createTypeName(\"ImageDimensionsType\"),\n\t\turl: scope.urlField,\n\t\tfixed: scope.fixedField,\n\t\tfluid: scope.fluidField,\n\t\tgatsbyImageData: scope.gatsbyImageDataField,\n\t\tlocalFile: {\n\t\t\ttype: \"File\",\n\t\t\textensions: { link: {} },\n\t\t},\n\t})),\n);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as ReadonlyA from \"fp-ts/ReadonlyArray\";\nimport * as S from \"fp-ts/Semigroup\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\nimport { getTypeName } from \"../lib/getTypeName\";\nimport { createType } from \"../lib/createType\";\n\nimport { buildImageBaseFieldConfigMap } from \"./buildImageBaseFieldConfigMap\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Creates a GraphQL type containing fields for thumbnails of an Image field.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL type name for the created type.\n */\n// TODO: Move `fields` typename to Dependencies (create in `buildDependencies.ts`).\nconst createThumbnailsType = (\n\tpath: string[],\n\t// schema: PrismicSchemaImageField,\n\tschema: prismicT.CustomTypeModelImageField,\n): RTE.ReaderTaskEither<Dependencies, never, string> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"thumbnails\", () => RTE.right(schema.config?.thumbnails ?? [])),\n\t\tRTE.bind(\"fields\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tR.fromFoldableMap(\n\t\t\t\t\tS.last<prismicT.CustomTypeModelImageThumbnail>(),\n\t\t\t\t\tReadonlyA.Foldable,\n\t\t\t\t)(scope.thumbnails, (thumbnail) => [thumbnail.name, thumbnail]),\n\t\t\t\tR.map(() => scope.nodeHelpers.createTypeName(\"ImageThumbnailType\")),\n\t\t\t\t(fields) => RTE.right(fields),\n\t\t\t),\n\t\t),\n\t\tRTE.chain((scope) =>\n\t\t\tbuildObjectType({\n\t\t\t\tname: scope.nodeHelpers.createTypeName([\n\t\t\t\t\t...path,\n\t\t\t\t\t\"ImageThumbnailsType\",\n\t\t\t\t]),\n\t\t\t\tfields: scope.fields,\n\t\t\t}),\n\t\t),\n\t\tRTE.chainFirst(createType),\n\t\tRTE.map(getTypeName),\n\t);\n\n/**\n * Builds a GraphQL field configuration object for an Image Custom Type field.\n * If the field is configured to have thumbnails, a field-specific type is\n * created for them.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildImageFieldConfig: FieldConfigCreator<prismicT.CustomTypeModelImageField> =\n\t(path, schema) =>\n\t\tpipe(\n\t\t\tRTE.ask<Dependencies>(),\n\t\t\tRTE.bind(\"thumbnailsTypeName\", () =>\n\t\t\t\tReadonlyA.isEmpty(schema.config?.thumbnails ?? [])\n\t\t\t\t\t? RTE.right(undefined)\n\t\t\t\t\t: createThumbnailsType(path, schema),\n\t\t\t),\n\t\t\tRTE.bind(\"baseFields\", () => buildImageBaseFieldConfigMap),\n\t\t\tRTE.chain((scope) =>\n\t\t\t\tbuildObjectType({\n\t\t\t\t\tname: scope.nodeHelpers.createTypeName([...path, \"ImageType\"]),\n\t\t\t\t\tfields: scope.thumbnailsTypeName\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...scope.baseFields,\n\t\t\t\t\t\t\t\tthumbnails: {\n\t\t\t\t\t\t\t\t\ttype: scope.thumbnailsTypeName,\n\t\t\t\t\t\t\t\t\tresolve: (source: prismicT.ImageField) => source,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: scope.baseFields,\n\t\t\t\t}),\n\t\t\t),\n\t\t\tRTE.chainFirst(createType),\n\t\t\tRTE.map(getTypeName),\n\t\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Link Custom Type field. The\n * resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildLinkFieldConfig: FieldConfigCreator = () =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.map((deps) => deps.nodeHelpers.createTypeName(\"LinkType\")),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Number Custom Type field.\n * The resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildNumberFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"Float\");\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Select Custom Type field.\n * The resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildSelectFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"String\");\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a StructuredText Custom Type\n * field. This is used for Rich Text and Title fields. The resulting\n * configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildStructuredTextFieldConfig: FieldConfigCreator = () =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.map((deps) => deps.nodeHelpers.createTypeName(\"StructuredTextType\")),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { createType } from \"./createType\";\n\n/**\n * Registers one or more types.\n *\n * @see gatsby-source-prismic/lib/registerType.ts\n */\nexport const createTypes = flow(A.map(createType), RTE.sequenceArray);\n","/**\n * Converts a given GraphQL type name to a required type.\n *\n * @example\n *\n * ```ts\n * requiredTypeName(\"MyType\"); // => \"MyType!\"\n * ```\n *\n * @param typeName - Type name to convert.\n *\n * @returns Type name as a required type.\n */\nexport const requiredTypeName = (typeName: string): string => typeName + \"!\";\n","import * as gatsby from \"gatsby\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as A from \"fp-ts/Array\";\nimport * as ReadonlyA from \"fp-ts/ReadonlyArray\";\nimport * as E from \"fp-ts/Either\";\nimport * as O from \"fp-ts/Option\";\nimport { pipe, flow, identity } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\nimport { buildSchemaRecordType } from \"../lib/buildSchemaRecordType\";\nimport { buildUnionType } from \"../lib/buildUnionType\";\nimport { getTypeName } from \"../lib/getTypeName\";\nimport { listTypeName } from \"../lib/listTypeName\";\nimport { createType } from \"../lib/createType\";\nimport { createTypes } from \"../lib/createTypes\";\nimport { requiredTypeName } from \"../lib/requiredTypeName\";\n\nimport { Dependencies, FieldConfigCreator, UnknownRecord } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Slice zone's Slice. Both\n * `non-repeat` and `repeat` schemas will be converted to GraphQL field\n * configuration objects. The resulting type can be created using Gatsby's\n * `createTypes` action.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the Slice zone.\n * @param model - Schema definition for the Slice.\n *\n * @returns GraphQL object type.\n */\nconst buildSliceType = (\n\tpath: string[],\n\tmodel: prismicT.CustomTypeModelSlice,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsby.GatsbyGraphQLObjectType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\t{} as Record<\n\t\t\t\t\t\"primary\" | \"items\",\n\t\t\t\t\tRTE.ReaderTaskEither<\n\t\t\t\t\t\tDependencies,\n\t\t\t\t\t\tnever,\n\t\t\t\t\t\tgatsby.GatsbyGraphQLObjectType\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tR.isEmpty(model[\"non-repeat\"])\n\t\t\t\t\t? identity\n\t\t\t\t\t: R.upsertAt(\n\t\t\t\t\t\t\t\"primary\",\n\t\t\t\t\t\t\tbuildSchemaRecordType([...path, \"primary\"], model[\"non-repeat\"]),\n\t\t\t\t\t  ),\n\t\t\t\tR.isEmpty(model.repeat)\n\t\t\t\t\t? identity\n\t\t\t\t\t: R.upsertAt(\n\t\t\t\t\t\t\t\"items\",\n\t\t\t\t\t\t\tbuildSchemaRecordType([...path, \"items\"], model.repeat, [\n\t\t\t\t\t\t\t\t...path,\n\t\t\t\t\t\t\t\t\"item\",\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t  ),\n\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t\tRTE.chainFirstW(\n\t\t\t\t\tflow(\n\t\t\t\t\t\tR.collect((_, type) => type),\n\t\t\t\t\t\tcreateTypes,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.map(\n\t\t\t\t\tR.mapWithIndex((field, type) =>\n\t\t\t\t\t\tfield === \"items\"\n\t\t\t\t\t\t\t? pipe(\n\t\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\t\tgetTypeName,\n\t\t\t\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t\t\t\t\tlistTypeName,\n\t\t\t\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: pipe(type, getTypeName, requiredTypeName),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.chainW((fields) =>\n\t\t\t\t\tbuildObjectType({\n\t\t\t\t\t\tname: deps.nodeHelpers.createTypeName(path),\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t...fields,\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"ID!\",\n\t\t\t\t\t\t\t\tresolve: (source: UnknownRecord): string =>\n\t\t\t\t\t\t\t\t\tdeps.nodeHelpers.createNodeId([\n\t\t\t\t\t\t\t\t\t\t...path,\n\t\t\t\t\t\t\t\t\t\tdeps.createContentDigest(source),\n\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tslice_type: \"String!\",\n\t\t\t\t\t\t\tslice_label: \"String\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinterfaces: [deps.globalNodeHelpers.createTypeName(\"SliceType\")],\n\t\t\t\t\t\textensions: { infer: false },\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t);\n\n/**\n * Builds GraphQL types for Slice Custom Type fields. The resulting types can be\n * created using Gatsby's `createTypes` action.\n *\n * @param path - Path to the fields.\n * @param choices - Record of Slice choices mapping a Slice API ID to its schema\n *   definition.\n *\n * @returns List of GraphQL types for the provided Slice schemas.\n */\nconst buildSliceTypes = (\n\tpath: string[],\n\tchoices: prismicT.CustomTypeModelSliceZoneField[\"config\"][\"choices\"],\n): RTE.ReaderTaskEither<Dependencies, Error, string[]> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bindW(\"sliceModels\", () =>\n\t\t\tpipe(\n\t\t\t\tchoices,\n\t\t\t\tR.filter(\n\t\t\t\t\t(slice): slice is prismicT.CustomTypeModelSlice =>\n\t\t\t\t\t\tslice.type === prismicT.CustomTypeModelSliceType.Slice,\n\t\t\t\t),\n\t\t\t\tRTE.right,\n\t\t\t),\n\t\t),\n\t\tRTE.bindW(\"sliceTypeNames\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.sliceModels,\n\t\t\t\tR.mapWithIndex((sliceName, sliceModel) =>\n\t\t\t\t\tbuildSliceType([...path, sliceName], sliceModel),\n\t\t\t\t),\n\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t\tRTE.map(R.collect((_, type) => type)),\n\t\t\t\tRTE.chainFirstW(createTypes),\n\t\t\t\tRTE.map(A.map(getTypeName)),\n\t\t\t),\n\t\t),\n\t\tRTE.bindW(\"sharedSliceModels\", () =>\n\t\t\tpipe(\n\t\t\t\tchoices,\n\t\t\t\tR.filter(\n\t\t\t\t\t(slice): slice is prismicT.CustomTypeModelSharedSlice =>\n\t\t\t\t\t\tslice.type === prismicT.CustomTypeModelSliceType.SharedSlice,\n\t\t\t\t),\n\t\t\t\tRTE.right,\n\t\t\t),\n\t\t),\n\t\tRTE.bindW(\"sharedSliceTypesNames\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.sharedSliceModels,\n\t\t\t\tR.keys,\n\t\t\t\tA.map((sharedSliceId) =>\n\t\t\t\t\tpipe(\n\t\t\t\t\t\tscope.pluginOptions.sharedSliceModels,\n\t\t\t\t\t\tA.findFirst(\n\t\t\t\t\t\t\t(sharedSliceModel) => sharedSliceModel.id === sharedSliceId,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tE.fromOption(\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Could not find a Shared Slice model for a Shared Slice named \"${sharedSliceId}\"`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tA.sequence(E.Applicative),\n\t\t\t\tRTE.fromEither,\n\t\t\t\tRTE.map(\n\t\t\t\t\tA.map((sharedSliceModel) =>\n\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\tsharedSliceModel.variations,\n\t\t\t\t\t\t\tReadonlyA.map((variation) =>\n\t\t\t\t\t\t\t\tscope.nodeHelpers.createTypeName([\n\t\t\t\t\t\t\t\t\tsharedSliceModel.id,\n\t\t\t\t\t\t\t\t\tvariation.id,\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.map(ReadonlyA.flatten),\n\t\t\t\tRTE.map(ReadonlyA.toArray),\n\t\t\t),\n\t\t),\n\t\tRTE.map((scope) => [\n\t\t\t...scope.sliceTypeNames,\n\t\t\t...scope.sharedSliceTypesNames,\n\t\t]),\n\t);\n\n/**\n * Builds a GraphQL field configuration object for a Slices Custom Type field\n * (also known as a Slice zone). The resulting configuration object can be used\n * in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildSlicesFieldConfig: FieldConfigCreator<prismicT.CustomTypeModelSliceZoneField> =\n\t(path, schema) =>\n\t\tpipe(\n\t\t\tRTE.ask<Dependencies>(),\n\t\t\tRTE.chain((deps) =>\n\t\t\t\tpipe(\n\t\t\t\t\tbuildSliceTypes(path, schema.config.choices),\n\t\t\t\t\tRTE.chainW((types) =>\n\t\t\t\t\t\tbuildUnionType({\n\t\t\t\t\t\t\tname: deps.nodeHelpers.createTypeName([...path, \"SlicesType\"]),\n\t\t\t\t\t\t\ttypes,\n\t\t\t\t\t\t\tresolveType: (source: prismicT.Slice | prismicT.SharedSlice) =>\n\t\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\tO.fromPredicate(\n\t\t\t\t\t\t\t\t\t\t(source): source is prismicT.SharedSlice =>\n\t\t\t\t\t\t\t\t\t\t\t\"variation\" in source,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tO.map((source) =>\n\t\t\t\t\t\t\t\t\t\tdeps.nodeHelpers.createTypeName([\n\t\t\t\t\t\t\t\t\t\t\tsource.slice_type,\n\t\t\t\t\t\t\t\t\t\t\tsource.variation,\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tO.getOrElse(() =>\n\t\t\t\t\t\t\t\t\t\tdeps.nodeHelpers.createTypeName([\n\t\t\t\t\t\t\t\t\t\t\t...path,\n\t\t\t\t\t\t\t\t\t\t\tsource.slice_type,\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t\tRTE.chainFirstW(createType),\n\t\t\t\t\tRTE.map(\n\t\t\t\t\t\tflow(getTypeName, requiredTypeName, listTypeName, requiredTypeName),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Text Custom Type field. The\n * resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildTextFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"String\");\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Timestamp Custom Type\n * field. It includes Gatsby's `@dateformat` extension. The resulting\n * configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildTimestampFieldConfig: FieldConfigCreator = () =>\n\tRTE.right({\n\t\ttype: \"Date\",\n\t\textensions: { dateformat: {} },\n\t});\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a UID Custom Type field. The\n * resulting configuration object can be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildUIDFieldConfig: FieldConfigCreator = () =>\n\tRTE.right(\"String!\");\n","/**\n * Converts a list of path edges to a string joined by dots (\"`.`\").\n *\n * @param path - List of path edges.\n *\n * @returns Paths joined by dots (\"`.`\").\n */\nexport const dotPath = (path: string[]): string => path.join(\".\");\n","/**\n * Interpolate values into a string using a `sprintf`-like syntax. Each instance\n * of \"`%s`\" in the string will be replaced with a given value in the order they\n * are given.\n *\n * @param string - String into which values will be interpolated.\n * @param args - Values which will be interpolated into `string`.\n *\n * @returns String with interpolated values.\n * @see https://gist.github.com/rmariuzzo/8761698#gistcomment-2375590\n */\nexport const sprintf = (string: string, ...args: string[]): string => {\n\tlet i = 0;\n\n\treturn string.replace(/%s/g, () => args[i++]);\n};\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { REPORTER_TEMPLATE } from \"../constants\";\nimport { sprintf } from \"./sprintf\";\n\n/**\n * Reports a piece of text at the \"info\" importance level using the\n * environment's `reportInfo` function.\n *\n * @param text - Text to report.\n */\nexport const reportInfo = (\n\ttext: string,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) =>\n\t\tpipe(\n\t\t\tsprintf(REPORTER_TEMPLATE, deps.pluginOptions.repositoryName, text),\n\t\t\tdeps.reportInfo,\n\t\t),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { identity, pipe } from \"fp-ts/function\";\n\nimport { dotPath } from \"../lib/dotPath\";\nimport { reportInfo } from \"../lib/reportInfo\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for a Custom Type field with an\n * unknown type. Because the type is unknown, a `JSON` field type is used as a\n * fallback type. The resulting configuration object can be used in a GraphQL type.\n *\n * Use of this function will be reported to the user's Gatsby log. This informs\n * the user that the field will not act like other fields since its type is\n * unknown. This should only happen if a new Prismic field type is introduced\n * before this plugin supports it.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildUnknownFieldConfig: FieldConfigCreator = (\n\tpath: string[],\n\tschema: prismicT.CustomTypeModelField,\n) =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chainFirst(() =>\n\t\t\treportInfo(\n\t\t\t\t`An unknown field type \"${schema.type}\" was found at ${dotPath(\n\t\t\t\t\tpath,\n\t\t\t\t)}. A generic JSON type will be used. You can manually override the type using Gatsby's createSchemaCustomization API in your site's gatsby-node.js.`,\n\t\t\t),\n\t\t),\n\t\tRTE.map(() => ({\n\t\t\ttype: \"JSON\",\n\t\t\tresolve: identity,\n\t\t})),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\nimport { buildObjectType } from \"./buildObjectType\";\n\n/**\n * Builds a GraphQL object type using Gatsby's Node interface with field\n * inference enabled using the environment's `buildObjectType` function.\n *\n * @param name - Name of type.\n *\n * @returns Return type of the envionrment's `buildObjectType` function.\n */\nexport const buildNamedInferredNodeType = (\n\tname: string,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLObjectType> =>\n\tbuildObjectType({\n\t\tname,\n\t\tinterfaces: [\"Node\"],\n\t\tfields: {},\n\t\textensions: { infer: true },\n\t});\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\nimport { buildNamedInferredNodeType } from \"./buildNamedInferredNodeType\";\n\n/**\n * Builds a GraphQL object type using Gatsby's Node interface with field\n * inference enabled using the environment's `buildObjectType` function. The\n * type name is generated using the environment's node helpers and the `path` parameter.\n *\n * @param path - List of field names from the root object to the field to which\n *   the inferred node type will be assigned. Determines the type's name.\n *\n * @returns Return type of the envionrment's `buildObjectType` function.\n */\nexport const buildInferredNodeType = (\n\tpath: string[],\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLObjectType> =>\n\tpipe(\n\t\tRTE.asks((deps: Dependencies) => deps.nodeHelpers.createTypeName(path)),\n\t\tRTE.chain(buildNamedInferredNodeType),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { buildInferredNodeType } from \"../lib/buildInferredNodeType\";\nimport { createType } from \"../lib/createType\";\nimport { getTypeName } from \"../lib/getTypeName\";\n\nimport { Dependencies, FieldConfigCreator } from \"../types\";\n\n/**\n * Builds a GraphQL field configuration object for an Integration Fields Custom\n * Type field. It uses the `@link` extension to connect data to the field. Data\n * for each Integration Fields field is created as a separate node to allow\n * Gatsby to infer the fields and types. The resulting configuration object can\n * be used in a GraphQL type.\n *\n * This function registers a typepath for the field.\n *\n * @param path - Path to the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const buildIntegrationFieldConfig: FieldConfigCreator = (\n\tpath: string[],\n) =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain(() => buildInferredNodeType([...path, \"IntegrationType\"])),\n\t\tRTE.chainFirst(createType),\n\t\tRTE.map(getTypeName),\n\t\tRTE.map((type) => ({\n\t\t\ttype,\n\t\t\textensions: { link: {} },\n\t\t})),\n\t);\n","import * as gqlc from \"graphql-compose\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\nimport { buildBooleanFieldConfig } from \"../builders/buildBooleanFieldConfig\";\nimport { buildColorFieldConfig } from \"../builders/buildColorFieldConfig\";\nimport { buildDateFieldConfig } from \"../builders/buildDateFieldConfig\";\nimport { buildEmbedFieldConfig } from \"../builders/buildEmbedFieldConfig\";\nimport { buildGeoPointFieldConfig } from \"../builders/buildGeoPointFieldConfig\";\nimport { buildGroupFieldConfig } from \"../builders/buildGroupFieldConfig\";\nimport { buildImageFieldConfig } from \"../builders/buildImageFieldConfig\";\nimport { buildLinkFieldConfig } from \"../builders/buildLinkFieldConfig\";\nimport { buildNumberFieldConfig } from \"../builders/buildNumberFieldConfig\";\nimport { buildSelectFieldConfig } from \"../builders/buildSelectFieldConfig\";\nimport { buildStructuredTextFieldConfig } from \"../builders/buildStructuredTextFieldConfig\";\nimport { buildSlicesFieldConfig } from \"../builders/buildSlicesFieldConfig\";\nimport { buildTextFieldConfig } from \"../builders/buildTextFieldConfig\";\nimport { buildTimestampFieldConfig } from \"../builders/buildTimestampFieldConfig\";\nimport { buildUIDFieldConfig } from \"../builders/buildUIDFieldConfig\";\nimport { buildUnknownFieldConfig } from \"../builders/buildUnknownFieldConfig\";\nimport { buildIntegrationFieldConfig } from \"../builders/buildIntegrationFieldConfig\";\n\n/**\n * Returns a GraphQL field configuration object for a Custom Type field. The\n * resulting configuration object can be used in a GraphQL type.\n *\n * In some cases, `undefined` will be returned. Fields that return `undefined`\n * should be omitted from the GraphQL schema.\n *\n * @param path - Path to the field.\n * @param schema - Schema definition for the field.\n *\n * @returns GraphQL field configuration object.\n */\nexport const toFieldConfig = (\n\tpath: string[],\n\tschema: prismicT.CustomTypeModelField,\n): RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgqlc.ObjectTypeComposerFieldConfigDefinition<unknown, unknown> | undefined\n> => {\n\tswitch (schema.type) {\n\t\tcase prismicT.CustomTypeModelFieldType.Boolean: {\n\t\t\treturn buildBooleanFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Color: {\n\t\t\treturn buildColorFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Date: {\n\t\t\treturn buildDateFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Embed: {\n\t\t\treturn buildEmbedFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.GeoPoint: {\n\t\t\treturn buildGeoPointFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Group: {\n\t\t\treturn buildGroupFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Image: {\n\t\t\treturn buildImageFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.IntegrationFields: {\n\t\t\treturn buildIntegrationFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Link: {\n\t\t\treturn buildLinkFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Number: {\n\t\t\treturn buildNumberFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Select: {\n\t\t\treturn buildSelectFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Slices: {\n\t\t\tif (\n\t\t\t\tschema.config.choices &&\n\t\t\t\tObject.keys(schema.config.choices).length > 0\n\t\t\t) {\n\t\t\t\treturn buildSlicesFieldConfig(path, schema);\n\t\t\t} else {\n\t\t\t\treturn RTE.right(undefined);\n\t\t\t}\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.StructuredText: {\n\t\t\treturn buildStructuredTextFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Text: {\n\t\t\treturn buildTextFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Timestamp: {\n\t\t\treturn buildTimestampFieldConfig(path, schema);\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.UID: {\n\t\t\treturn buildUIDFieldConfig(path, schema);\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn buildUnknownFieldConfig(path, schema);\n\t\t}\n\t}\n};\n","import * as gqlc from \"graphql-compose\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { mapRecordIndices } from \"./mapRecordIndices\";\nimport { toFieldConfig } from \"./toFieldConfig\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a `graphql-compose`-compatible field config map by calling\n * `lib/toFieldConfig` for each field.\n *\n * Field names are transformed using the environment's plugin options's\n * `transformFieldName` function.\n *\n * @param path - Field path leading to `fieldSchemas`'s location.\n * @param fieldSchemas - Record of Prismic custom type schema fields.\n *\n * @returns Field config map including `fieldSchemas`'s fields.\n */\nexport const buildFieldConfigMap = (\n\tpath: string[],\n\tfieldSchemas: Record<string, prismicT.CustomTypeModelField>,\n): RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgqlc.ObjectTypeComposerFieldConfigMapDefinition<unknown, unknown>\n> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\tfieldSchemas,\n\t\t\t\tmapRecordIndices(deps.transformFieldName),\n\t\t\t\tR.mapWithIndex((name, schema) =>\n\t\t\t\t\ttoFieldConfig(pipe(path, A.append(name)), schema),\n\t\t\t\t),\n\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t),\n\t\t),\n\t\tRTE.map(\n\t\t\tR.filter((fieldConfig): fieldConfig is NonNullable<typeof fieldConfig> =>\n\t\t\t\tBoolean(fieldConfig),\n\t\t\t),\n\t\t),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as S from \"fp-ts/Semigroup\";\nimport * as A from \"fp-ts/Array\";\nimport * as struct from \"fp-ts/struct\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, PrismicAPIDocumentNode } from \"../types\";\nimport { PREVIEWABLE_NODE_ID_FIELD } from \"../constants\";\nimport { getTypeName } from \"./getTypeName\";\nimport { buildObjectType } from \"./buildObjectType\";\nimport { createType } from \"./createType\";\nimport { buildFieldConfigMap } from \"./buildFieldConfigMap\";\nimport { listTypeName } from \"./listTypeName\";\nimport { requiredTypeName } from \"./requiredTypeName\";\n\n/**\n * Returns all fields from a Prismic Custom Type schema definition. It\n * effectively gathers all fields for each tab into one object.\n *\n * @param schema - Schema definition for a Custom Type.\n *\n * @returns Record of fields for the Custom Type.\n */\nconst collectFields = (\n\tschema: prismicT.CustomTypeModel,\n): Record<string, prismicT.CustomTypeModelField> =>\n\tpipe(\n\t\tschema.json,\n\t\tR.collect((_, value) => value),\n\t\tS.concatAll(struct.getAssignSemigroup<prismicT.CustomTypeModelTab>())({}),\n\t);\n\n/**\n * Builds a record of GraphQL field configuration objects containing a Custom\n * Type's `data` fields. The resulting record can be used within a GraphQL type\n * for the Custom Type.\n *\n * @param customTypeName - API ID of the Custom Type.\n * @param fields - Record mapping Custom Type field API IDs to their schema definitions.\n *\n * @returns Record of GraphQL field configuration objects containing\n *   `data`-related fields.\n */\nconst buildDataFieldConfigMap = (\n\tcustomTypeName: string,\n\tfields: Record<string, prismicT.CustomTypeModelField>,\n): RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\t| gqlc.ObjectTypeComposerFieldConfigMapDefinition<\n\t\t\tPrismicAPIDocumentNode,\n\t\t\tunknown\n\t  >\n\t| undefined\n> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.filterOrElse(\n\t\t\t() => !R.isEmpty(fields),\n\t\t\t() => new Error(\"No data fields in schema\"),\n\t\t),\n\t\tRTE.bindW(\"fieldConfigMap\", () =>\n\t\t\tbuildFieldConfigMap([customTypeName, \"data\"], fields),\n\t\t),\n\t\tRTE.chainW((scope) =>\n\t\t\tbuildObjectType({\n\t\t\t\tname: scope.nodeHelpers.createTypeName([customTypeName, \"DataType\"]),\n\t\t\t\tfields: scope.fieldConfigMap,\n\t\t\t}),\n\t\t),\n\t\tRTE.chainFirstW(createType),\n\t\tRTE.map(getTypeName),\n\t\tRTE.map((typeName) => ({\n\t\t\tdata: pipe(typeName, requiredTypeName),\n\t\t\tdataRaw: {\n\t\t\t\ttype: \"JSON!\",\n\t\t\t\tresolve: (source: PrismicAPIDocumentNode) => source.data,\n\t\t\t},\n\t\t})),\n\t\t// We will be spreading the return value of this function into the\n\t\t// document's config map, so we can return undefined as an empty value.\n\t\t// Leaving it as an E.left would have stopped the custom type from being\n\t\t// created.\n\t\tRTE.orElse(() =>\n\t\t\tRTE.right(\n\t\t\t\tundefined as\n\t\t\t\t\t| gqlc.ObjectTypeComposerFieldConfigMapDefinition<\n\t\t\t\t\t\t\tPrismicAPIDocumentNode,\n\t\t\t\t\t\t\tunknown\n\t\t\t\t\t  >\n\t\t\t\t\t| undefined,\n\t\t\t),\n\t\t),\n\t);\n\n/**\n * Creates a GraphQL type for a Custom Type. This function also registers a\n * root-level typepath for the Custom Type.\n *\n * @param name - API ID of the Custom Type\n * @param customType - Schema definition for the Custom Type.\n *\n * @returns GraphQL type for the Custom Type.\n */\nexport const createCustomType = (\n\tcustomType: prismicT.CustomTypeModel,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsby.GatsbyGraphQLObjectType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"fields\", () => RTE.right(collectFields(customType))),\n\t\tRTE.bind(\"partitionedFields\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.fields,\n\t\t\t\tR.partition(\n\t\t\t\t\t(field) => field.type === prismicT.CustomTypeModelFieldType.UID,\n\t\t\t\t),\n\t\t\t\t(partitionedFields) => RTE.right(partitionedFields),\n\t\t\t),\n\t\t),\n\t\tRTE.bind(\"rootFieldConfigMap\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.partitionedFields.right,\n\t\t\t\tR.collect((k, a) => [k, a] as [string, prismicT.CustomTypeModelField]),\n\t\t\t\tA.map(\n\t\t\t\t\t([k, a]) =>\n\t\t\t\t\t\t(a.type === prismicT.CustomTypeModelFieldType.UID\n\t\t\t\t\t\t\t? [\"uid\", a]\n\t\t\t\t\t\t\t: [k, a]) as [string, prismicT.CustomTypeModelField],\n\t\t\t\t),\n\t\t\t\tR.fromFoldable(S.last<prismicT.CustomTypeModelField>(), A.Foldable),\n\t\t\t\t(fields) => buildFieldConfigMap([customType.id], fields),\n\t\t\t),\n\t\t),\n\t\tRTE.bindW(\"dataFieldConfigMap\", (scope) =>\n\t\t\tbuildDataFieldConfigMap(customType.id, scope.partitionedFields.left),\n\t\t),\n\t\tRTE.chainW((scope) =>\n\t\t\tbuildObjectType({\n\t\t\t\tname: scope.nodeHelpers.createTypeName(customType.id),\n\t\t\t\tfields: {\n\t\t\t\t\t...scope.rootFieldConfigMap,\n\t\t\t\t\t...scope.dataFieldConfigMap,\n\t\t\t\t\t[scope.nodeHelpers.createFieldName(\"id\") as \"id\"]: \"ID!\",\n\t\t\t\t\talternate_languages: pipe(\n\t\t\t\t\t\tscope.nodeHelpers.createTypeName(\"AlternateLanguageType\"),\n\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t\tlistTypeName,\n\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t),\n\t\t\t\t\tfirst_publication_date: {\n\t\t\t\t\t\ttype: \"Date!\",\n\t\t\t\t\t\textensions: { dateformat: {} },\n\t\t\t\t\t},\n\t\t\t\t\thref: \"String!\",\n\t\t\t\t\tlang: \"String!\",\n\t\t\t\t\tlast_publication_date: {\n\t\t\t\t\t\ttype: \"Date!\",\n\t\t\t\t\t\textensions: { dateformat: {} },\n\t\t\t\t\t},\n\t\t\t\t\ttags: \"[String!]!\",\n\t\t\t\t\ttype: \"String!\",\n\t\t\t\t\turl: {\n\t\t\t\t\t\ttype: \"String\",\n\t\t\t\t\t\tresolve: (source: PrismicAPIDocumentNode) =>\n\t\t\t\t\t\t\tprismicH.asLink(source, scope.pluginOptions.linkResolver),\n\t\t\t\t\t},\n\t\t\t\t\t[PREVIEWABLE_NODE_ID_FIELD]: {\n\t\t\t\t\t\ttype: \"ID!\",\n\t\t\t\t\t\tresolve: (source: PrismicAPIDocumentNode) =>\n\t\t\t\t\t\t\tsource[scope.nodeHelpers.createFieldName(\"id\")],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinterfaces: [\"Node\"],\n\t\t\t\textensions: { infer: false },\n\t\t\t}),\n\t\t),\n\t\tRTE.chainFirstW(createType),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as ReadonlyA from \"fp-ts/ReadonlyArray\";\nimport { pipe, flow, identity } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\nimport { buildSchemaRecordType } from \"../lib/buildSchemaRecordType\";\nimport { getTypeName } from \"../lib/getTypeName\";\nimport { listTypeName } from \"../lib/listTypeName\";\nimport { createTypes } from \"../lib/createTypes\";\n\nimport { Dependencies, Mutable, UnknownRecord } from \"../types\";\nimport { requiredTypeName } from \"../lib/requiredTypeName\";\n\n/**\n * @returns GraphQL object type.\n */\nconst buildSharedSliceVariationType = (\n\tpath: string[],\n\tvariationModel: prismicT.SharedSliceModelVariation,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsby.GatsbyGraphQLObjectType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\t{} as Record<\n\t\t\t\t\t\"primary\" | \"items\",\n\t\t\t\t\tRTE.ReaderTaskEither<\n\t\t\t\t\t\tDependencies,\n\t\t\t\t\t\tnever,\n\t\t\t\t\t\tgatsby.GatsbyGraphQLObjectType\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tR.isEmpty(variationModel.primary)\n\t\t\t\t\t? identity\n\t\t\t\t\t: R.upsertAt(\n\t\t\t\t\t\t\t\"primary\",\n\t\t\t\t\t\t\tbuildSchemaRecordType(\n\t\t\t\t\t\t\t\t[...path, variationModel.id, \"primary\"],\n\t\t\t\t\t\t\t\tvariationModel.primary,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  ),\n\t\t\t\tR.isEmpty(variationModel.items)\n\t\t\t\t\t? identity\n\t\t\t\t\t: R.upsertAt(\n\t\t\t\t\t\t\t\"items\",\n\t\t\t\t\t\t\tbuildSchemaRecordType(\n\t\t\t\t\t\t\t\t[...path, variationModel.id, \"items\"],\n\t\t\t\t\t\t\t\tvariationModel.items,\n\t\t\t\t\t\t\t\t[...path, variationModel.id, \"item\"],\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  ),\n\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t\tRTE.chainFirstW(\n\t\t\t\t\tflow(\n\t\t\t\t\t\tR.collect((_, type) => type),\n\t\t\t\t\t\tcreateTypes,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.map(\n\t\t\t\t\tR.mapWithIndex((field, type) =>\n\t\t\t\t\t\tfield === \"items\"\n\t\t\t\t\t\t\t? pipe(\n\t\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\t\tgetTypeName,\n\t\t\t\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t\t\t\t\tlistTypeName,\n\t\t\t\t\t\t\t\t\trequiredTypeName,\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: pipe(type, getTypeName, requiredTypeName),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.chainW((fields) =>\n\t\t\t\t\tbuildObjectType({\n\t\t\t\t\t\tname: deps.nodeHelpers.createTypeName([...path, variationModel.id]),\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t...fields,\n\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\ttype: \"ID!\",\n\t\t\t\t\t\t\t\tresolve: (source: UnknownRecord): string =>\n\t\t\t\t\t\t\t\t\tdeps.nodeHelpers.createNodeId([\n\t\t\t\t\t\t\t\t\t\t...path,\n\t\t\t\t\t\t\t\t\t\tvariationModel.id,\n\t\t\t\t\t\t\t\t\t\tdeps.createContentDigest(source),\n\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tslice_type: \"String!\",\n\t\t\t\t\t\t\tslice_label: \"String\",\n\t\t\t\t\t\t\tversion: \"String!\",\n\t\t\t\t\t\t\tvariation: \"String!\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinterfaces: [\n\t\t\t\t\t\t\tdeps.globalNodeHelpers.createTypeName(\"SliceType\"),\n\t\t\t\t\t\t\tdeps.globalNodeHelpers.createTypeName(\"SharedSliceType\"),\n\t\t\t\t\t\t],\n\t\t\t\t\t\textensions: { infer: false },\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t);\n\n/**\n * Builds GraphQL types for a Shared Slice's variations. The resulting types can\n * be created using Gatsby's `createTypes` action.\n *\n * @param path - Path to the Shared Slice.\n * @param variations - List of Shared Slice variations.\n *\n * @returns List of GraphQL types for each Shared Slice variation.\n */\nexport const buildSharedSliceVariationTypes = (\n\tpath: string[],\n\tvariations: prismicT.SharedSliceModel[\"variations\"],\n): RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgatsby.GatsbyGraphQLObjectType[]\n> =>\n\tpipe(\n\t\tRTE.right(variations),\n\t\tRTE.map(\n\t\t\tReadonlyA.map((variation) =>\n\t\t\t\tbuildSharedSliceVariationType(path, variation),\n\t\t\t),\n\t\t),\n\t\tRTE.chain(RTE.sequenceArray),\n\t\tRTE.map((types) => types as Mutable<typeof types>),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildSharedSliceVariationTypes } from \"../builders/buildSharedSliceVariationTypes\";\nimport { createType } from \"./createType\";\nimport { createTypes } from \"./createTypes\";\nimport { getTypeName } from \"./getTypeName\";\nimport { buildUnionType } from \"./buildUnionType\";\n\nexport const createSharedSlice = (\n\tsharedSliceModel: prismicT.SharedSliceModel,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsby.GatsbyGraphQLUnionType> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"variationTypes\", () =>\n\t\t\tpipe(\n\t\t\t\tbuildSharedSliceVariationTypes(\n\t\t\t\t\t[sharedSliceModel.id],\n\t\t\t\t\tsharedSliceModel.variations,\n\t\t\t\t),\n\t\t\t\tRTE.chainFirstW(createTypes),\n\t\t\t\tRTE.map(A.map(getTypeName)),\n\t\t\t),\n\t\t),\n\t\tRTE.chainW((scope) =>\n\t\t\tbuildUnionType({\n\t\t\t\tname: scope.nodeHelpers.createTypeName([sharedSliceModel.id]),\n\t\t\t\ttypes: scope.variationTypes,\n\t\t\t\tresolveType: (source: prismicT.SharedSlice) =>\n\t\t\t\t\tscope.nodeHelpers.createTypeName([\n\t\t\t\t\t\tsource.slice_type,\n\t\t\t\t\t\tsource.variation,\n\t\t\t\t\t]),\n\t\t\t}),\n\t\t),\n\t\tRTE.chainFirstW(createType),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as I from \"fp-ts/Identity\";\nimport { pipe } from \"fp-ts/function\";\nimport { IdentifiableRecord } from \"gatsby-node-helpers\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Creates a node using the environment's `createNode` function. The provided\n * record is passed through a node helper factory based on the record's `type` field.\n *\n * @param record - Record with an `id` field with which to create a node.\n * @param type - Type of the record.\n */\nexport const createNodeOfType = (\n\trecord: IdentifiableRecord,\n\ttype: string | string[],\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.NodeInput> =>\n\tRTE.asks((deps) =>\n\t\tpipe(\n\t\t\trecord,\n\t\t\tdeps.nodeHelpers.createNodeFactory(type),\n\t\t\tI.chainFirst(deps.createNode),\n\t\t),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { constVoid, pipe } from \"fp-ts/function\";\n\nimport { createNodeOfType } from \"./createNodeOfType\";\n\nimport { Dependencies, SerializedTypePath } from \"../types\";\n\n/**\n * Creates a type path using the environment's `createTypePath` function.\n *\n * @param path - Path to the field.\n * @param type - Type of the field.\n */\nexport const createTypePath = (\n\tserializedTypePath: SerializedTypePath,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tpipe(\n\t\tRTE.right({\n\t\t\tid: serializedTypePath.path,\n\t\t\tkind: serializedTypePath.kind,\n\t\t\tpath: serializedTypePath.path,\n\t\t\ttype: serializedTypePath.type,\n\t\t}),\n\t\tRTE.chain((node) => createNodeOfType(node, \"TypePathType\")),\n\t\tRTE.map(constVoid),\n\t);\n","import * as prismic from \"@prismicio/client\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as prismicCustomTypes from \"@prismicio/custom-types-client\";\nimport * as gatsbyFs from \"gatsby-source-filesystem\";\nimport nodeFetch from \"node-fetch\";\n\nimport { UnpreparedPluginOptions, PluginOptions } from \"../types\";\nimport {\n\tDEFAULT_IMGIX_PARAMS,\n\tDEFAULT_LANG,\n\tDEFAULT_PLACEHOLDER_IMGIX_PARAMS,\n} from \"../constants\";\n\n/**\n * Converts a Custom Type model to a mocked Custom Type API response object.\n * This is used as a way to ease migration from the `schemas` plugin option to\n * the `customTypeModels` plugin option.\n *\n * The `label`, `status`, and `repeatable` fields will **not** represent the\n * actual values from the Prismic repository. They will contain placeholder\n * values since that data is not available from just the Custom Type model.\n *\n * @param id - API ID of the Custom Type.\n * @param modelDefinition - Model for the Custom Type.\n *\n * @returns The Custom Type model as if it came from the\n */\nconst customTypeModelDefinitionToCustomTypeModel = (\n\tid: string,\n\tmodelDefinition: prismicT.CustomTypeModelDefinition,\n): prismicT.CustomTypeModel => ({\n\tid,\n\tjson: modelDefinition,\n\t// The following values are treated as filler values since we don't have this\n\t// metadata. They do **not** accurately represent the Custom Type.\n\tlabel: id,\n\tstatus: true,\n\trepeatable: true,\n});\n\n/**\n * Merge arrays by performing a shallow equality check on an element's property.\n *\n * @param property - The property to compare.\n * @param a - The base array.\n * @param b - The priority array. Elements in this array take priority over\n *   equal items in `a`. Items are considered equal by comparing the value of\n *   the element's `property`.\n *\n * @returns An array containing elements from `a` and `b`.\n */\nconst shallowArrayMergeByProperty = <\n\tP extends string,\n\tR extends Record<P, unknown>,\n>(\n\tproperty: P,\n\ta: R[],\n\tb: R[],\n) => {\n\treturn [\n\t\t...a.filter(\n\t\t\t(aElement) =>\n\t\t\t\t!b.some((bElement) =>\n\t\t\t\t\tObject.is(bElement[property], aElement[property]),\n\t\t\t\t),\n\t\t),\n\t\t...b,\n\t];\n};\n\nexport const preparePluginOptions = async (\n\tunpreparedPluginOptions: UnpreparedPluginOptions,\n): Promise<PluginOptions> => {\n\tconst result: PluginOptions = {\n\t\tapiEndpoint: prismic.getEndpoint(unpreparedPluginOptions.repositoryName),\n\t\timageImgixParams: DEFAULT_IMGIX_PARAMS,\n\t\timagePlaceholderImgixParams: DEFAULT_PLACEHOLDER_IMGIX_PARAMS,\n\t\tshouldDownloadFiles: {},\n\t\tcreateRemoteFileNode: gatsbyFs.createRemoteFileNode,\n\t\ttransformFieldName: (fieldName: string) => fieldName.replace(/-/g, \"_\"),\n\t\tfetch: nodeFetch,\n\t\tcustomTypeModels: [],\n\t\tsharedSliceModels: [],\n\t\tlang: DEFAULT_LANG,\n\t\t...unpreparedPluginOptions,\n\t};\n\n\t// Support deprecated `schemas` plugin option containing Custom Type model\n\t// definitions.\n\tif (unpreparedPluginOptions.schemas) {\n\t\tconst convertedModels = Object.keys(unpreparedPluginOptions.schemas)\n\t\t\t.map((id) => {\n\t\t\t\tif (unpreparedPluginOptions.schemas) {\n\t\t\t\t\tconst modelDefinition = unpreparedPluginOptions.schemas[id];\n\n\t\t\t\t\treturn customTypeModelDefinitionToCustomTypeModel(\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter((model): model is prismicT.CustomTypeModel => Boolean(model));\n\n\t\t// Models provided to `customTypeModels` take priority.\n\t\tresult.customTypeModels = shallowArrayMergeByProperty(\n\t\t\t\"id\",\n\t\t\tconvertedModels,\n\t\t\tresult.customTypeModels,\n\t\t);\n\t}\n\n\t// Fetch models using the Custom Types API if a token is provided.\n\tif (unpreparedPluginOptions.customTypesApiToken) {\n\t\tconst customTypesClient = prismicCustomTypes.createClient({\n\t\t\trepositoryName: unpreparedPluginOptions.repositoryName,\n\t\t\ttoken: unpreparedPluginOptions.customTypesApiToken,\n\t\t\tendpoint: unpreparedPluginOptions.customTypesApiEndpoint,\n\t\t\tfetch: result.fetch,\n\t\t});\n\n\t\tconst customTypeModels = await customTypesClient.getAllCustomTypes();\n\t\tconst sharedSliceModels = await customTypesClient.getAllSharedSlices();\n\n\t\t// Models provided to `customTypeModels` take priority.\n\t\tresult.customTypeModels = shallowArrayMergeByProperty(\n\t\t\t\"id\",\n\t\t\tcustomTypeModels,\n\t\t\tresult.customTypeModels,\n\t\t);\n\n\t\t// Models provided to `sharedSliceModels` take priority.\n\t\tresult.sharedSliceModels = shallowArrayMergeByProperty(\n\t\t\t\"id\",\n\t\t\tsharedSliceModels,\n\t\t\tresult.sharedSliceModels,\n\t\t);\n\t}\n\n\treturn result;\n};\n","/**\n * Throws an error.\n *\n * @param error - Error to throw.\n */\nexport const throwError = (error: Error): never => {\n\tthrow error;\n};\n","import * as gatsby from \"gatsby\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe, identity } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\nimport { Dependencies, IterableElement } from \"../types\";\n\n/**\n * Builds a GraphQL Type used by a document's `alternate_language` field. The\n * resulting type can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildAlternateLanguageType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildObjectType({\n\t\t\tname: deps.nodeHelpers.createTypeName(\"AlternateLanguageType\"),\n\t\t\tfields: {\n\t\t\t\tid: \"ID\",\n\t\t\t\tuid: \"String\",\n\t\t\t\tlang: \"String\",\n\t\t\t\ttype: \"String\",\n\t\t\t\tdocument: {\n\t\t\t\t\ttype: deps.nodeHelpers.createTypeName(\"AllDocumentTypes\"),\n\t\t\t\t\tresolve: (\n\t\t\t\t\t\tsource: IterableElement<\n\t\t\t\t\t\t\tprismicT.PrismicDocument[\"alternate_languages\"]\n\t\t\t\t\t\t>,\n\t\t\t\t\t): string | null => deps.nodeHelpers.createNodeId(source.id),\n\t\t\t\t\textensions: { link: {} },\n\t\t\t\t},\n\t\t\t\traw: { type: \"JSON\", resolve: identity },\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { buildNamedInferredNodeType } from \"../lib/buildNamedInferredNodeType\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL type used by Embed fields. The resulting type can be created\n * using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildEmbedType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.asks((deps: Dependencies) =>\n\t\tdeps.nodeHelpers.createTypeName(\"EmbedType\"),\n\t),\n\tRTE.chain(buildNamedInferredNodeType),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL type used by GeoPoint fields. The resulting type can be\n * created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildGeoPointType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildObjectType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"GeoPointType\"),\n\t\t\tfields: {\n\t\t\t\tlongitude: \"Float!\",\n\t\t\t\tlatitude: \"Float!\",\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\n/**\n * Builds a GraphQL type used by Image fields for their `dimensions` field. The\n * resulting type can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildImageDimensionsType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildObjectType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"ImageDimensionsType\"),\n\t\t\tfields: {\n\t\t\t\twidth: \"Int!\",\n\t\t\t\theight: \"Int!\",\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\nimport { buildImageBaseFieldConfigMap } from \"./buildImageBaseFieldConfigMap\";\n\n/**\n * Builds a GraphQL type used by an Image field's thumbnails. The resulting type\n * can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildImageThumbnailType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.bind(\"imageFields\", () => buildImageBaseFieldConfigMap),\n\tRTE.chain((scope) =>\n\t\tbuildObjectType({\n\t\t\tname: scope.nodeHelpers.createTypeName(\"ImageThumbnailType\"),\n\t\t\tfields: scope.imageFields,\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as imgixGatsby from \"@imgix/gatsby/dist/pluginHelpers\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a list of Imgix GraphQL types used by Image Custom Type fields. The\n * resulting types can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildImgixImageTypes: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType[]\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.bind(\"imgixTypes\", (scope) =>\n\t\tRTE.right(\n\t\t\t// IMPORTANT: These options need to be kept in sync with the options at\n\t\t\t// packages/gatsby-source-prismic/src/builders/buildImageBaseFieldConfigMap.ts\n\t\t\timgixGatsby.createImgixGatsbyTypes({\n\t\t\t\tcache: scope.cache,\n\t\t\t\tresolveUrl: () => \"\", // Doesn't matter\n\t\t\t\tnamespace: \"Imgix\",\n\t\t\t}),\n\t\t),\n\t),\n\tRTE.bind(\"objectTypes\", (scope) =>\n\t\tRTE.right(\n\t\t\tpipe(scope.imgixTypes.types, A.map(scope.schema.buildObjectType)),\n\t\t),\n\t),\n\tRTE.bind(\"enumTypes\", (scope) =>\n\t\tRTE.right(\n\t\t\tpipe(scope.imgixTypes.enumTypes, A.map(scope.schema.buildEnumType)),\n\t\t),\n\t),\n\tRTE.bind(\"inputTypes\", (scope) =>\n\t\tRTE.right(\n\t\t\tpipe(\n\t\t\t\tscope.imgixTypes.inputTypes,\n\t\t\t\tA.map(scope.schema.buildInputObjectType),\n\t\t\t),\n\t\t),\n\t),\n\tRTE.map((scope) => [\n\t\t...scope.objectTypes,\n\t\t...scope.enumTypes,\n\t\t...scope.inputTypes,\n\t]),\n);\n","import * as gatsby from \"gatsby\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe, identity } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL Type used by Link fields. The resulting type can be created\n * using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildLinkType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildObjectType({\n\t\t\tname: deps.nodeHelpers.createTypeName(\"LinkType\"),\n\t\t\tfields: {\n\t\t\t\tlink_type: deps.globalNodeHelpers.createTypeName(\"LinkTypeEnum\"),\n\t\t\t\tisBroken: \"Boolean\",\n\t\t\t\turl: {\n\t\t\t\t\ttype: \"String\",\n\t\t\t\t\tresolve: (source: prismicT.LinkField): string | null =>\n\t\t\t\t\t\tprismicH.asLink(source, deps.pluginOptions.linkResolver),\n\t\t\t\t},\n\t\t\t\ttarget: \"String\",\n\t\t\t\tsize: \"Int\",\n\t\t\t\tid: \"ID\",\n\t\t\t\ttype: \"String\",\n\t\t\t\ttags: \"[String]\",\n\t\t\t\tlang: \"String\",\n\t\t\t\tslug: \"String\",\n\t\t\t\tuid: \"String\",\n\t\t\t\tdocument: {\n\t\t\t\t\ttype: deps.nodeHelpers.createTypeName(\"AllDocumentTypes\"),\n\t\t\t\t\tresolve: (source: prismicT.LinkField): string | null =>\n\t\t\t\t\t\tsource.link_type === prismicT.LinkType.Document &&\n\t\t\t\t\t\t\"isBroken\" in source &&\n\t\t\t\t\t\t!source.isBroken\n\t\t\t\t\t\t\t? deps.nodeHelpers.createNodeId(source.id)\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\textensions: { link: {} },\n\t\t\t\t},\n\t\t\t\tlocalFile: {\n\t\t\t\t\ttype: \"File\",\n\t\t\t\t\textensions: {\n\t\t\t\t\t\tlink: {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\traw: { type: \"JSON\", resolve: identity },\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL enum type using the environment's `buildEnumType` function.\n *\n * @param config - Configuration for the enum type.\n *\n * @returns Return value of the environment's `buildEnumType` function.\n */\nexport const buildEnumType = (\n\tconfig: gqlc.EnumTypeComposerAsObjectDefinition,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLEnumType> =>\n\tRTE.asks((deps) => deps.buildEnumType(config));\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildEnumType } from \"../lib/buildEnumType\";\n\n/**\n * Builds a GraphQL type used by a Link field's `type` field. The resulting type\n * can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildLinkTypeEnumType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildEnumType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"LinkTypeEnum\"),\n\t\t\tvalues: { Any: {}, Document: {}, Media: {}, Web: {} },\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL interface type using the environment's `buildInterfaceType` function.\n *\n * @param config - Configuration for the interface type.\n *\n * @returns Return value of the environment's `buildInterfaceType` function.\n */\nexport const buildInterfaceType = <TSource, TContext>(\n\tconfig: gqlc.InterfaceTypeComposerAsObjectDefinition<TSource, TContext>,\n): RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLInterfaceType\n> => RTE.asks((deps) => deps.buildInterfaceType(config));\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildInterfaceType } from \"../lib/buildInterfaceType\";\n\n/**\n * Builds a GraphQL Interface type for Shared Slice fields. It includes fields\n * common to all Shared Slices. The resulting type can be created using Gatsby's\n * `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildSharedSliceInterface: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildInterfaceType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"SharedSliceType\"),\n\t\t\tfields: {\n\t\t\t\tid: \"ID!\",\n\t\t\t\tslice_type: \"String!\",\n\t\t\t\tslice_label: \"String\",\n\t\t\t\tvariation: \"String!\",\n\t\t\t\tversion: \"String!\",\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildInterfaceType } from \"../lib/buildInterfaceType\";\n\n/**\n * Builds a GraphQL Interface type for Slice fields. It includes fields common\n * to all Slices. The resulting type can be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildSliceInterface: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildInterfaceType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"SliceType\"),\n\t\t\tfields: {\n\t\t\t\tid: \"ID!\",\n\t\t\t\tslice_type: \"String!\",\n\t\t\t\tslice_label: \"String\",\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Builds a GraphQL scalar type using the environment's `buildScalarType` function.\n *\n * @param config - Configuration for the scalar type.\n *\n * @returns Return value of the environment's `buildScalarType` function.\n */\nexport const buildScalarType = (\n\tconfig: gqlc.ScalarTypeComposerAsObjectDefinition,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.GatsbyGraphQLScalarType> =>\n\tRTE.asks((deps) => deps.buildScalarType(config));\n","import * as gatsby from \"gatsby\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe, identity } from \"fp-ts/function\";\n\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\nimport { Dependencies } from \"../types\";\nimport { buildScalarType } from \"../lib/buildScalarType\";\nimport { requiredTypeName } from \"../lib/requiredTypeName\";\nimport { createType } from \"../lib/createType\";\n\n/**\n * Builds a GraphQL Type used by StructuredText fields. The resulting type can\n * be created using Gatsby's `createTypes` action.\n */\n// TODO: Move typename to Dependencies (create in `buildDependencies.ts`).\nexport const buildStructuredTextType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.bind(\"structuredTextScalar\", (deps) =>\n\t\tbuildScalarType({\n\t\t\tname: deps.globalNodeHelpers.createTypeName(\"StructuredText\"),\n\t\t\tdescription:\n\t\t\t\t\"Text content with rich formatting capabilities using a Prismic format called Structured Text.\",\n\t\t}),\n\t),\n\tRTE.chainFirst((scope) => createType(scope.structuredTextScalar)),\n\tRTE.chain((scope) =>\n\t\tbuildObjectType({\n\t\t\tname: scope.nodeHelpers.createTypeName(\"StructuredTextType\"),\n\t\t\tfields: {\n\t\t\t\ttext: {\n\t\t\t\t\ttype: \"String\",\n\t\t\t\t\tresolve: (source: prismicT.RichTextField) => prismicH.asText(source),\n\t\t\t\t},\n\t\t\t\thtml: {\n\t\t\t\t\ttype: \"String\",\n\t\t\t\t\tresolve: (source: prismicT.RichTextField) =>\n\t\t\t\t\t\tprismicH.asHTML(\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tscope.pluginOptions.linkResolver,\n\t\t\t\t\t\t\tscope.pluginOptions.htmlSerializer,\n\t\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\trichText: {\n\t\t\t\t\ttype: requiredTypeName(scope.structuredTextScalar.config.name),\n\t\t\t\t\tresolve: identity,\n\t\t\t\t},\n\t\t\t\traw: {\n\t\t\t\t\ttype: requiredTypeName(scope.structuredTextScalar.config.name),\n\t\t\t\t\tresolve: identity,\n\t\t\t\t\tdeprecationReason:\n\t\t\t\t\t\t\"This field has been renamed to `richText`. The `richText` field has the same value the `raw` field.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { buildObjectType } from \"../lib/buildObjectType\";\n\n/**\n * Builds a GraphQL type used to map a Custom Type's fields to an Prismic field\n * type enum value. The resulting type can be created using Gatsby's\n * `createTypes` action.\n */\nexport const buildTypePathType: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.GatsbyGraphQLType\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tbuildObjectType({\n\t\t\tname: deps.nodeHelpers.createTypeName(\"TypePathType\"),\n\t\t\tfields: {\n\t\t\t\tkind: \"String!\",\n\t\t\t\tpath: \"[String!]!\",\n\t\t\t\ttype: \"String!\",\n\t\t\t},\n\t\t\tinterfaces: [\"Node\"],\n\t\t\textensions: { infer: false },\n\t\t}),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as gatsbyFs from \"gatsby-source-filesystem\";\nimport * as imgixGatsby from \"@imgix/gatsby\";\nimport * as prismic from \"@prismicio/client\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as prismicCustomTypes from \"@prismicio/custom-types-client\";\nimport * as gqlc from \"graphql-compose\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { NodeHelpers } from \"gatsby-node-helpers\";\n\nimport { Runtime } from \"./runtime\";\n\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport type UnknownRecord<K extends PropertyKey = PropertyKey> = Record<\n\tK,\n\tunknown\n>;\n\nexport type IterableElement<TargetIterable> = TargetIterable extends Iterable<\n\tinfer ElementType\n>\n\t? ElementType\n\t: never;\n\nexport type JoiValidationError = InstanceType<\n\tgatsby.PluginOptionsSchemaArgs[\"Joi\"][\"ValidationError\"]\n>;\n\nexport type PrismicDocumentNodeInput<\n\tTDocument extends prismicT.PrismicDocument = prismicT.PrismicDocument,\n> = TDocument & gatsby.NodeInput & { prismicId: string };\n\nexport enum TypePathKind {\n\tCustomType = \"CustomType\",\n\tSharedSliceVariation = \"SharedSliceVariation\",\n\tField = \"Field\",\n}\n\nexport interface TypePath {\n\tkind: TypePathKind;\n\tpath: string[];\n\ttype: PrismicTypePathType;\n}\n\nexport interface SerializedTypePath extends Omit<TypePath, \"path\"> {\n\tpath: string;\n}\n\nexport type TypePathNode = TypePath & gatsby.Node;\n\nexport type TransformFieldNameFn = (fieldName: string) => string;\n\nexport interface Dependencies {\n\tprismicClient: prismic.Client;\n\tcreateTypes: gatsby.Actions[\"createTypes\"];\n\tcreateNode: gatsby.Actions[\"createNode\"];\n\tbuildObjectType: gatsby.NodePluginSchema[\"buildObjectType\"];\n\tbuildUnionType: gatsby.NodePluginSchema[\"buildUnionType\"];\n\tbuildEnumType: gatsby.NodePluginSchema[\"buildEnumType\"];\n\tbuildScalarType: gatsby.NodePluginSchema[\"buildScalarType\"];\n\tbuildInterfaceType: gatsby.NodePluginSchema[\"buildInterfaceType\"];\n\tgetNode: gatsby.SourceNodesArgs[\"getNode\"];\n\tgetNodes: gatsby.SourceNodesArgs[\"getNodes\"];\n\ttouchNode: gatsby.Actions[\"touchNode\"];\n\tdeleteNode: gatsby.Actions[\"deleteNode\"];\n\tcreateNodeId: gatsby.NodePluginArgs[\"createNodeId\"];\n\tcreateContentDigest: gatsby.NodePluginArgs[\"createContentDigest\"];\n\tschema: gatsby.NodePluginSchema;\n\tcache: gatsby.GatsbyCache;\n\tstore: gatsby.Store;\n\treporter: gatsby.Reporter;\n\treportInfo: gatsby.Reporter[\"info\"];\n\treportWarning: gatsby.Reporter[\"warn\"];\n\treportVerbose: gatsby.Reporter[\"verbose\"];\n\tglobalNodeHelpers: NodeHelpers;\n\tnodeHelpers: NodeHelpers;\n\tpluginOptions: PluginOptions;\n\twebhookBody?: unknown;\n\tcreateRemoteFileNode: typeof gatsbyFs.createRemoteFileNode;\n\ttransformFieldName: TransformFieldNameFn;\n\truntime: Runtime;\n}\n\ntype ShouldDownloadFilesPredicate = (\n\tfield: prismicT.ImageFieldImage | prismicT.LinkToMediaField,\n) => boolean;\n\nexport type UnpreparedPluginOptions = gatsby.PluginOptions & {\n\trepositoryName: string;\n\taccessToken?: string;\n\tapiEndpoint?: string;\n\tcustomTypesApiEndpoint?: string;\n\treleaseID?: string;\n\tgraphQuery?: string;\n\tfetchLinks?: string[];\n\tlang?: string;\n\tpageSize?: number;\n\tlinkResolver?: prismicH.LinkResolverFunction;\n\troutes?: prismic.Route[];\n\thtmlSerializer?: prismicH.HTMLFunctionSerializer | prismicH.HTMLMapSerializer;\n\timageImgixParams?: imgixGatsby.ImgixUrlParams;\n\timagePlaceholderImgixParams?: imgixGatsby.ImgixUrlParams;\n\ttypePrefix?: string;\n\twebhookSecret?: string;\n\tshouldDownloadFiles?:\n\t\t| boolean\n\t\t| ShouldDownloadFilesPredicate\n\t\t| Record<string, boolean | ShouldDownloadFilesPredicate>;\n\tcreateRemoteFileNode?: typeof gatsbyFs.createRemoteFileNode;\n\ttransformFieldName?: TransformFieldNameFn;\n\tfetch?: prismic.FetchLike & prismicCustomTypes.FetchLike;\n\n\tcustomTypesApiToken?: string;\n\t/**\n\t * A record of all Custom Type API IDs mapped to their models.\n\t *\n\t * @deprecated Use the `customTypeModels` plugin option.\n\t */\n\tschemas?: Record<string, prismicT.CustomTypeModelDefinition>;\n\t/**\n\t * A list of all Custom Types models using the Custom Types API object shape.\n\t */\n\tcustomTypeModels?: prismicT.CustomTypeModel[];\n\t/**\n\t * A list of all Shared Slice models.\n\t */\n\tsharedSliceModels?: prismicT.SharedSliceModel[];\n};\n\nexport type PluginOptions = UnpreparedPluginOptions &\n\tRequired<\n\t\tPick<\n\t\t\tUnpreparedPluginOptions,\n\t\t\t| \"apiEndpoint\"\n\t\t\t| \"customTypeModels\"\n\t\t\t| \"sharedSliceModels\"\n\t\t\t| \"imageImgixParams\"\n\t\t\t| \"imagePlaceholderImgixParams\"\n\t\t\t| \"shouldDownloadFiles\"\n\t\t\t| \"createRemoteFileNode\"\n\t\t\t| \"transformFieldName\"\n\t\t\t| \"fetch\"\n\t\t>\n\t>;\n\nexport type FieldConfigCreator<\n\tTSchema extends prismicT.CustomTypeModelField = prismicT.CustomTypeModelField,\n> = (\n\tpath: string[],\n\tschema: TSchema,\n) => RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgqlc.ObjectTypeComposerFieldConfigDefinition<unknown, unknown>\n>;\n\nexport type PrismicTypePathType =\n\t| PrismicSpecialType\n\t| typeof prismicT.CustomTypeModelFieldType[keyof typeof prismicT.CustomTypeModelFieldType]\n\t| typeof prismicT.CustomTypeModelSliceType[keyof typeof prismicT.CustomTypeModelSliceType];\n\nexport enum PrismicSpecialType {\n\tDocument = \"Document\",\n\tDocumentData = \"DocumentData\",\n\tSharedSliceVariation = \"SharedSliceVariation\",\n\tUnknown = \"Unknown\",\n}\n\nexport interface PrismicAPIDocumentNode\n\textends prismicT.PrismicDocument,\n\t\tgatsby.Node {\n\tprismicId: string;\n}\n\nexport type PrismicWebhookBody =\n\t| PrismicWebhookBodyApiUpdate\n\t| PrismicWebhookBodyTestTrigger;\n\nexport enum PrismicWebhookType {\n\tAPIUpdate = \"api-update\",\n\tTestTrigger = \"test-trigger\",\n}\n\ninterface PrismicWebhookBodyBase {\n\ttype: PrismicWebhookType;\n\tdomain: string;\n\tapiUrl: string;\n\tsecret: string | null;\n}\n\nexport interface PrismicWebhookBodyApiUpdate extends PrismicWebhookBodyBase {\n\ttype: PrismicWebhookType.APIUpdate;\n\tmasterRef?: string;\n\treleases: PrismicWebhookOperations<PrismicWebhookRelease>;\n\tmasks: PrismicWebhookOperations<PrismicWebhookMask>;\n\ttags: PrismicWebhookOperations<PrismicWebhookTag>;\n\tdocuments: string[];\n\texperiments?: PrismicWebhookOperations<PrismicWebhookExperiment>;\n}\n\nexport interface PrismicWebhookBodyTestTrigger extends PrismicWebhookBodyBase {\n\ttype: PrismicWebhookType.TestTrigger;\n}\n\ninterface PrismicWebhookOperations<T> {\n\tupdate?: T[];\n\taddition?: T[];\n\tdeletion?: T[];\n}\n\ninterface PrismicWebhookMask {\n\tid: string;\n\tlabel: string;\n}\n\ninterface PrismicWebhookTag {\n\tid: string;\n}\n\nexport interface PrismicWebhookRelease {\n\tid: string;\n\tref: string;\n\tlabel: string;\n\tdocuments: string[];\n}\n\n/**\n * @deprecated Experiments are no longer supported by Prismic.\n */\ninterface PrismicWebhookExperiment {\n\tid: string;\n\tname: string;\n\tvariations: PrismicWebhookExperimentVariation[];\n}\n\n/**\n * @deprecated Experiments are no longer supported by Prismic.\n */\ninterface PrismicWebhookExperimentVariation {\n\tid: string;\n\tref: string;\n\tlabel: string;\n}\n\nexport type PrismicCustomTypeApiResponse = PrismicCustomTypeApiCustomType[];\n\nexport interface PrismicCustomTypeApiCustomType<\n\tModel extends prismicT.CustomTypeModel = prismicT.CustomTypeModel,\n> {\n\tid: string;\n\tlabel: string;\n\trepeatable: boolean;\n\tjson: Model;\n}\n","/**\n * Symbol used to identify if a value is a proxy. Attach this to proxies (done\n * automatically via `lib/createGetProxy`).\n */\nexport const IS_PROXY = Symbol(\"IS_PROXY\");\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const createGetProxy = <T extends object>(\n\ttarget: T,\n\tget: ProxyHandler<T>[\"get\"],\n): T => {\n\t// @ts-expect-error - We are forcibly adding this \"is proxy\" property\n\ttarget[IS_PROXY] = true;\n\n\treturn new Proxy(target, { get });\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { createGetProxy } from \"../createGetProxy\";\nimport { NormalizeConfig, NormalizerDependencies } from \"../types\";\n\nimport { NormalizedDocumentValue } from \"./document\";\n\nexport type NormalizeAlternateLanguagesConfig = NormalizeConfig<\n\tprismicT.PrismicDocument[\"alternate_languages\"]\n> &\n\tPick<NormalizerDependencies, \"getNode\">;\n\nexport type NormalizedAlternateLanguagesValue = (prismicT.AlternateLanguage & {\n\tdocument?: NormalizedDocumentValue | null;\n\traw: prismicT.AlternateLanguage;\n})[];\n\nexport const alternateLanguages = (\n\tconfig: NormalizeAlternateLanguagesConfig,\n): NormalizedAlternateLanguagesValue => {\n\treturn config.value.map((alternateLanguage) => {\n\t\tconst value = {\n\t\t\t...alternateLanguage,\n\t\t\traw: alternateLanguage,\n\t\t};\n\n\t\treturn createGetProxy(value, (target, prop, receiver) => {\n\t\t\tif (prop === \"document\") {\n\t\t\t\treturn config.getNode(value.id) || null;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t});\n\t});\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as gatsby from \"gatsby\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizedValueMap,\n\tNormalizerDependencies,\n} from \"../types\";\nimport { normalize } from \"../normalize\";\nimport {\n\talternateLanguages,\n\tNormalizedAlternateLanguagesValue,\n} from \"./alternateLanguages\";\nimport { NormalizedDocumentDataValue } from \"./documentData\";\n\nexport const isDocument = (\n\tvalue: unknown,\n): value is prismicT.PrismicDocument => {\n\treturn typeof value === \"object\" && value !== null && \"type\" in value;\n};\n\ntype NormalizeDocumentConfig<Value extends prismicT.PrismicDocument> =\n\tNormalizeConfig<Value> & NormalizerDependencies;\n\nexport type NormalizedDocumentValue<\n\tValue extends prismicT.PrismicDocument = prismicT.PrismicDocument,\n> = Omit<Value, \"alternate_languages\" | \"data\"> & {\n\t__typename: string;\n\t_previewable: string;\n\tprismicId: string;\n\talternate_languages: NormalizedAlternateLanguagesValue;\n\tdata: NormalizedValueMap<Value[\"data\"]>;\n\tdataRaw: Value[\"data\"];\n} & gatsby.NodeInput;\n\nexport const document = <Value extends prismicT.PrismicDocument>(\n\tconfig: NormalizeDocumentConfig<Value>,\n): NormalizedDocumentValue<Value> => {\n\tconst fields = {\n\t\t...config.value,\n\t\t__typename: config.nodeHelpers.createTypeName(config.path),\n\t\t_previewable: config.value.id,\n\t\talternate_languages: alternateLanguages({\n\t\t\t...config,\n\t\t\tvalue: config.value[\"alternate_languages\"],\n\t\t}),\n\t\turl: prismicH.asLink(config.value, config.linkResolver),\n\t\tdata: {},\n\t\tdataRaw: config.value.data,\n\t};\n\n\tif (Object.keys(config.value.data).length > 0) {\n\t\tfields.data = normalize({\n\t\t\t...config,\n\t\t\tvalue: config.value.data,\n\t\t\tpath: [...config.path, \"data\"],\n\t\t}) as NormalizedDocumentDataValue<Value[\"data\"]>;\n\t}\n\n\treturn config.nodeHelpers.createNodeFactory(config.value.type)(\n\t\tfields,\n\t) as NormalizedDocumentValue<Value>;\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizedValueMap,\n\tNormalizerDependencies,\n} from \"../types\";\nimport { normalize } from \"../normalize\";\n\nexport const isDocumentDataField = (\n\tvalue: unknown,\n): value is prismicT.PrismicDocument[\"data\"] => {\n\treturn typeof value === \"object\" && value !== null;\n};\n\ntype NormalizeDocumentDataConfig<\n\tValue extends prismicT.PrismicDocument[\"data\"],\n> = NormalizeConfig<Value> & NormalizerDependencies;\n\nexport type NormalizedDocumentDataValue<\n\tValue extends prismicT.PrismicDocument[\"data\"] = prismicT.PrismicDocument[\"data\"],\n> = NormalizedValueMap<Value>;\n\nexport const documentData = <Value extends prismicT.PrismicDocument[\"data\"]>(\n\tconfig: NormalizeDocumentDataConfig<Value>,\n): NormalizedDocumentDataValue<Value> => {\n\tconst result = {} as NormalizedDocumentDataValue<Value>;\n\n\tfor (const key in config.value) {\n\t\tconst transformedKey = config.transformFieldName(\n\t\t\tkey,\n\t\t) as keyof NormalizedDocumentDataValue<Value>;\n\n\t\tresult[transformedKey] = normalize({\n\t\t\t...config,\n\t\t\tvalue: config.value[key],\n\t\t\tpath: [...config.path, transformedKey as string],\n\t\t});\n\t}\n\n\treturn result;\n};\n","import * as prismicT from \"@prismicio/types\";\nimport { IterableElement } from \"type-fest\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizedValueMap,\n\tNormalizerDependencies,\n} from \"../types\";\nimport { normalize } from \"../normalize\";\n\nexport const isGroupField = (value: unknown): value is prismicT.GroupField => {\n\treturn (\n\t\tArray.isArray(value) &&\n\t\tvalue.every((element) => typeof element === \"object\" && element !== null)\n\t);\n};\n\ntype NormalizeGroupConfig<Value extends prismicT.GroupField> =\n\tNormalizeConfig<Value> & NormalizerDependencies;\n\nexport type NormalizedGroupValue<\n\tValue extends prismicT.GroupField = prismicT.GroupField,\n> = NormalizedValueMap<IterableElement<Value>>[];\n\nexport const group = <Value extends prismicT.GroupField>(\n\tconfig: NormalizeGroupConfig<Value>,\n): NormalizedGroupValue<Value> => {\n\treturn config.value.map((element) => {\n\t\tconst result: NormalizedValueMap<typeof element> = {};\n\n\t\tfor (const key in element) {\n\t\t\tconst transformedKey = config.transformFieldName(key);\n\n\t\t\tresult[transformedKey] = normalize({\n\t\t\t\t...config,\n\t\t\t\tvalue: element[key],\n\t\t\t\tpath: [...config.path, transformedKey],\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}) as NormalizedGroupValue<Value>;\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as gatsbyImage from \"gatsby-image\";\nimport * as gatsbyPluginImage from \"gatsby-plugin-image\";\nimport * as imgixGatsby from \"@imgix/gatsby\";\nimport * as imgixGatsbyHelpers from \"@imgix/gatsby/dist/pluginHelpers.browser\";\n\nimport { sanitizeImageURL } from \"../../lib/sanitizeImageURL\";\nimport { stripURLQueryParameters } from \"../../lib/stripURLParameters\";\n\nimport { NormalizeConfig, NormalizerDependencies } from \"../types\";\nimport { PRISMIC_API_IMAGE_FIELDS } from \"../../constants\";\n\nconst getURLSearchParams = (url: string): Record<string, string> => {\n\tconst urlInstance = new URL(url);\n\tconst result: Record<string, string> = {};\n\n\tfor (const [key, value] of urlInstance.searchParams.entries()) {\n\t\tresult[key] = value;\n\t}\n\n\treturn result;\n};\n\nexport const isImageField = (value: unknown): value is prismicT.ImageField => {\n\t// Unfortunately, we can't check for specific properties here since it's\n\t// possible for the object to be empty if an image was never set.\n\treturn typeof value === \"object\" && value !== null;\n};\n\nexport type NormalizeImageConfig<\n\tValue extends prismicT.ImageField = prismicT.ImageField,\n> = NormalizeConfig<Value> &\n\tPick<\n\t\tNormalizerDependencies,\n\t\t\"imageImgixParams\" | \"imagePlaceholderImgixParams\"\n\t>;\n\ntype NormalizedImageBase<Value extends prismicT.ImageFieldImage> =\n\tValue extends prismicT.FilledImageFieldImage\n\t\t? Value & {\n\t\t\t\tfixed: gatsbyImage.FixedObject;\n\t\t\t\tfluid: gatsbyImage.FluidObject;\n\t\t\t\tgatsbyImageData: gatsbyPluginImage.IGatsbyImageData;\n\t\t\t\tlocalFile: {\n\t\t\t\t\tpublicURL: Value[\"url\"];\n\t\t\t\t\tchildImageSharp: {\n\t\t\t\t\t\tfixed: gatsbyImage.FixedObject;\n\t\t\t\t\t\tfluid: gatsbyImage.FluidObject;\n\t\t\t\t\t\tgatsbyImageData: gatsbyPluginImage.IGatsbyImageData;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t  }\n\t\t: Value extends prismicT.EmptyImageFieldImage\n\t\t? Value & {\n\t\t\t\tfixed: null;\n\t\t\t\tfluid: null;\n\t\t\t\tgatsbyImageData: null;\n\t\t\t\tlocalFile: null;\n\t\t  }\n\t\t: never;\n\nexport type NormalizedImageValue<Value extends prismicT.ImageField> =\n\tNormalizedImageBase<Value> & {\n\t\tthumbnails: Record<string, NormalizedImageBase<prismicT.ImageFieldImage>>;\n\t};\n\ntype BuildImageFieldConfig<Value extends prismicT.ImageFieldImage> = {\n\tvalue: Value;\n\timageImgixParams: imgixGatsby.ImgixUrlParams;\n\timagePlaceholderImgixParams: imgixGatsby.ImgixUrlParams;\n};\n\nconst buildImageField = <Value extends prismicT.ImageFieldImage>(\n\tconfig: BuildImageFieldConfig<Value>,\n): NormalizedImageBase<Value> => {\n\tif (config.value.url) {\n\t\tconst imgixParams = {\n\t\t\t...getURLSearchParams(config.value.url),\n\t\t\t...config.imageImgixParams,\n\t\t};\n\t\tconst placeholderImgixParams = config.imagePlaceholderImgixParams;\n\n\t\tconst url = new URL(config.value.url);\n\n\t\tconst normalizedURL = sanitizeImageURL(\n\t\t\tstripURLQueryParameters(url.toString()),\n\t\t);\n\n\t\tconst populatedUrl = new URL(url.toString());\n\t\tfor (const paramKey in imgixParams) {\n\t\t\tpopulatedUrl.searchParams.set(\n\t\t\t\tparamKey,\n\t\t\t\tString(imgixParams[paramKey as keyof typeof imgixParams]),\n\t\t\t);\n\t\t}\n\n\t\tconst fixed = imgixGatsbyHelpers.buildFixedObject({\n\t\t\turl: normalizedURL,\n\t\t\targs: {\n\t\t\t\twidth: 400,\n\t\t\t\timgixParams,\n\t\t\t\tplaceholderImgixParams,\n\t\t\t},\n\t\t\tsourceWidth: config.value.dimensions.width,\n\t\t\tsourceHeight: config.value.dimensions.height,\n\t\t});\n\n\t\tconst fluid = imgixGatsbyHelpers.buildFluidObject({\n\t\t\turl: normalizedURL,\n\t\t\targs: {\n\t\t\t\tmaxWidth: 800,\n\t\t\t\timgixParams,\n\t\t\t\tplaceholderImgixParams,\n\t\t\t},\n\t\t\tsourceWidth: config.value.dimensions.width,\n\t\t\tsourceHeight: config.value.dimensions.height,\n\t\t});\n\n\t\tconst gatsbyImageData = imgixGatsbyHelpers.buildGatsbyImageDataObject({\n\t\t\turl: normalizedURL,\n\t\t\tdimensions: config.value.dimensions,\n\t\t\tdefaultParams: imgixParams,\n\t\t\tresolverArgs: {},\n\t\t});\n\n\t\treturn {\n\t\t\turl: sanitizeImageURL(populatedUrl.toString()),\n\t\t\talt: config.value.alt,\n\t\t\tcopyright: config.value.copyright,\n\t\t\tdimensions: config.value.dimensions,\n\t\t\tfixed,\n\t\t\tfluid,\n\t\t\tgatsbyImageData,\n\t\t\tlocalFile: {\n\t\t\t\tpublicURL: config.value.url,\n\t\t\t\tchildImageSharp: {\n\t\t\t\t\tfixed,\n\t\t\t\t\tfluid,\n\t\t\t\t\tgatsbyImageData,\n\t\t\t\t},\n\t\t\t},\n\t\t} as NormalizedImageBase<Value>;\n\t} else {\n\t\treturn {\n\t\t\turl: null,\n\t\t\talt: null,\n\t\t\tcopyright: null,\n\t\t\tdimensions: null,\n\t\t\tfixed: null,\n\t\t\tgatsbyImageData: null,\n\t\t\tfluid: null,\n\t\t\tlocalFile: null,\n\t\t} as NormalizedImageBase<Value>;\n\t}\n};\n\nexport const image = <Value extends prismicT.ImageField>(\n\tconfig: NormalizeImageConfig<Value>,\n): NormalizedImageValue<Value> => {\n\tconst result = {\n\t\t...buildImageField({\n\t\t\tvalue: config.value,\n\t\t\timageImgixParams: config.imageImgixParams,\n\t\t\timagePlaceholderImgixParams: config.imagePlaceholderImgixParams,\n\t\t}),\n\t\tthumbnails: {},\n\t} as NormalizedImageValue<Value>;\n\n\tconst thumbnailNames = Object.keys(config.value).filter(\n\t\t(key) => !PRISMIC_API_IMAGE_FIELDS.includes(key),\n\t);\n\n\tfor (const thumbnailName of thumbnailNames) {\n\t\tresult.thumbnails[thumbnailName as keyof typeof result.thumbnails] =\n\t\t\tbuildImageField({\n\t\t\t\tvalue: config.value[thumbnailName as keyof typeof config.value],\n\t\t\t\timageImgixParams: config.imageImgixParams,\n\t\t\t\timagePlaceholderImgixParams: config.imagePlaceholderImgixParams,\n\t\t\t});\n\t}\n\n\treturn result;\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\n\nimport { PrismicDocumentNodeInput } from \"../../types\";\n\nimport { createGetProxy } from \"../createGetProxy\";\nimport { NormalizeConfig, NormalizerDependencies } from \"../types\";\n\nexport const isLinkField = (value: unknown): value is prismicT.LinkField => {\n\treturn typeof value === \"object\" && (value === null || \"link_type\" in value);\n};\n\nexport type NormalizeLinkConfig<\n\tValue extends prismicT.LinkField = prismicT.LinkField,\n> = NormalizeConfig<Value> &\n\tPick<NormalizerDependencies, \"linkResolver\" | \"getNode\">;\n\nexport type NormalizedLinkValue<Value extends prismicT.LinkField> = Value & {\n\turl?: string | null;\n\traw: Value;\n\tdocument?: PrismicDocumentNodeInput | null;\n\tlocalFile?: {\n\t\tpublicURL: string;\n\t};\n};\n\nexport const link = <Value extends prismicT.LinkField>(\n\tconfig: NormalizeLinkConfig<Value>,\n): NormalizedLinkValue<Value> => {\n\tconst value: NormalizedLinkValue<Value> = {\n\t\t...config.value,\n\t\turl: prismicH.asLink(config.value, config.linkResolver),\n\t\tlocalFile: undefined,\n\t\traw: config.value,\n\t};\n\n\tif (\n\t\tconfig.value.link_type === prismicT.LinkType.Media &&\n\t\t\"url\" in config.value\n\t) {\n\t\tvalue.localFile = {\n\t\t\tpublicURL: config.value.url,\n\t\t};\n\t}\n\n\treturn createGetProxy(value, (target, prop, receiver) => {\n\t\tif (\n\t\t\tprop === \"document\" &&\n\t\t\tconfig.value.link_type === prismicT.LinkType.Document &&\n\t\t\t\"id\" in config.value &&\n\t\t\t!config.value.isBroken\n\t\t) {\n\t\t\treturn config.getNode(config.value.id) || null;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t});\n};\n","import * as prismicH from \"@prismicio/helpers\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizerDependencies,\n\tStructuredTextField,\n} from \"../types\";\n\nexport const isStructuredTextField = (\n\tvalue: unknown,\n): value is StructuredTextField => {\n\t// We must be very loose here. An image element, for example, does not\n\t// contain a `text` property.\n\treturn Array.isArray(value) && value.every((element) => \"type\" in element);\n};\n\nexport type NormalizeStructuredTextConfig<\n\tValue extends StructuredTextField = StructuredTextField,\n> = NormalizeConfig<Value> &\n\tPick<NormalizerDependencies, \"linkResolver\" | \"htmlSerializer\">;\n\nexport type NormalizedStructuredTextValue<Value extends StructuredTextField> = {\n\thtml: string;\n\ttext: string;\n\trichText: Value;\n\traw: Value;\n};\n\nexport const structuredText = <Value extends StructuredTextField>(\n\tconfig: NormalizeStructuredTextConfig<Value>,\n): NormalizedStructuredTextValue<Value> => {\n\treturn {\n\t\thtml: prismicH.asHTML(\n\t\t\tconfig.value,\n\t\t\tconfig.linkResolver,\n\t\t\tconfig.htmlSerializer,\n\t\t),\n\t\ttext: prismicH.asText(config.value),\n\t\trichText: config.value,\n\t\traw: config.value,\n\t};\n};\n","import * as prismicT from \"@prismicio/types\";\nimport { IterableElement } from \"type-fest\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizedValueMap,\n\tNormalizerDependencies,\n} from \"../types\";\nimport { normalize } from \"../normalize\";\n\nexport const isSlice = (\n\tvalue: unknown,\n): value is prismicT.Slice | prismicT.SharedSlice => {\n\treturn typeof value === \"object\" && value !== null && \"slice_type\" in value;\n};\n\nexport const isSharedSlice = (\n\tvalue: prismicT.Slice,\n): value is prismicT.SharedSlice => \"variation\" in value;\n\nexport type NormalizeSliceConfig<Value extends prismicT.Slice> =\n\tNormalizeConfig<Value> & NormalizerDependencies;\n\nexport type NormalizedSliceValue<\n\tValue extends prismicT.Slice | prismicT.SharedSlice =\n\t\t| prismicT.Slice\n\t\t| prismicT.SharedSlice,\n> = Value extends prismicT.SharedSlice\n\t? {\n\t\t\t__typename: string;\n\t\t\tid: string;\n\t\t\tslice_type: Value[\"slice_type\"];\n\t\t\tslice_label: Value[\"slice_label\"];\n\t\t\tvariation: string;\n\t\t\tversion: string;\n\t\t\tprimary: NormalizedValueMap<Value[\"primary\"]>;\n\t\t\titems: NormalizedValueMap<IterableElement<Value[\"items\"]>>[];\n\t  }\n\t: {\n\t\t\t__typename: string;\n\t\t\tid: string;\n\t\t\tslice_type: Value[\"slice_type\"];\n\t\t\tslice_label: Value[\"slice_label\"];\n\t\t\tprimary: NormalizedValueMap<Value[\"primary\"]>;\n\t\t\titems: NormalizedValueMap<IterableElement<Value[\"items\"]>>[];\n\t  };\n\nexport const slice = <Value extends prismicT.Slice | prismicT.SharedSlice>(\n\tconfig: NormalizeSliceConfig<Value>,\n): NormalizedSliceValue<Value> => {\n\tconst { primary, items, ...value } = config.value;\n\n\tconst result = {\n\t\t...value,\n\t\t__typename: config.nodeHelpers.createTypeName(config.path),\n\t\tid: config.nodeHelpers.createNodeId([\n\t\t\t...config.path,\n\t\t\tJSON.stringify(config.value),\n\t\t]),\n\t\tslice_type: config.value.slice_type,\n\t\tslice_label: config.value.slice_label,\n\t} as unknown as NormalizedSliceValue<Value>;\n\t// Yes, using `as unknown as X` is bad practice.\n\t// Yes, you can fix this if you know how to do it.\n\t// Yes, that means you!\n\n\tresult.primary = {} as NormalizedSliceValue[\"primary\"];\n\n\tfor (const key in primary) {\n\t\tconst transformedKey = config.transformFieldName(\n\t\t\tkey,\n\t\t) as keyof NormalizedSliceValue[\"primary\"];\n\n\t\tresult.primary[transformedKey] = normalize({\n\t\t\t...config,\n\t\t\tvalue: config.value.primary[key],\n\t\t\tpath: [...config.path, \"primary\", transformedKey],\n\t\t});\n\t}\n\n\tresult.items = items.map((item) => {\n\t\tconst result = {} as IterableElement<NormalizedSliceValue[\"items\"]>;\n\n\t\tfor (const key in item) {\n\t\t\tconst transformedKey = config.transformFieldName(\n\t\t\t\tkey,\n\t\t\t) as keyof IterableElement<NormalizedSliceValue[\"items\"]>;\n\n\t\t\tresult[transformedKey] = normalize({\n\t\t\t\t...config,\n\t\t\t\tvalue: item[key],\n\t\t\t\tpath: [...config.path, \"items\", transformedKey],\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t});\n\n\treturn result;\n};\n","import * as prismicT from \"@prismicio/types\";\nimport { IterableElement, Simplify } from \"type-fest\";\n\nimport {\n\tNormalizeConfig,\n\tNormalizedValue,\n\tNormalizerDependencies,\n} from \"../types\";\nimport { normalize } from \"../normalize\";\nimport { isSharedSlice, isSlice } from \"./slice\";\n\nexport const isSlices = (value: unknown): value is prismicT.SliceZone => {\n\treturn Array.isArray(value) && value.every((element) => isSlice(element));\n};\n\ntype NormalizeSlicesConfig<Value extends prismicT.SliceZone> =\n\tNormalizeConfig<Value> & NormalizerDependencies;\n\nexport type NormalizedSlicesValue<\n\tValue extends prismicT.SliceZone = prismicT.SliceZone,\n> = NormalizedValue<Simplify<IterableElement<Value>>>[];\n\nexport const slices = <Value extends prismicT.SliceZone>(\n\tconfig: NormalizeSlicesConfig<Value>,\n): NormalizedSlicesValue<Value> => {\n\treturn config.value.map((element) => {\n\t\treturn normalize({\n\t\t\t...config,\n\t\t\tvalue: element,\n\t\t\tpath: isSharedSlice(element)\n\t\t\t\t? [element.slice_type, element.variation]\n\t\t\t\t: [...config.path, element.slice_type],\n\t\t});\n\t}) as NormalizedSlicesValue<Value>;\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { PrismicSpecialType } from \"../types\";\n\nimport * as normalizers from \"./normalizers\";\nimport {\n\tNormalizedValue,\n\tStructuredTextField,\n\tNormalizeConfig as BaseNormalizeConfig,\n\tNormalizerDependencies,\n} from \"./types\";\n\nfunction assertType<T>(\n\ttype:\n\t\t| prismicT.CustomTypeModelFieldType\n\t\t| prismicT.CustomTypeModelSliceType\n\t\t| PrismicSpecialType,\n\tguard: (value: unknown) => boolean,\n\tvalue: unknown,\n): asserts value is T {\n\tif (!guard(value)) {\n\t\tthrow new Error(`Value is not expected type ${type}`);\n\t}\n}\n\ntype NormalizeConfig<Value> = BaseNormalizeConfig<Value> &\n\tNormalizerDependencies;\n\nexport const normalize = <Value>(\n\tconfig: NormalizeConfig<Value>,\n): NormalizedValue<Value> => {\n\tconst type = config.getTypePath(config.path);\n\tif (!type) {\n\t\tthrow new Error(\n\t\t\t`No type for path: ${config.path.join(\n\t\t\t\t\".\",\n\t\t\t)}. Did you register the Custom Type model?`,\n\t\t);\n\t}\n\n\tswitch (type.type) {\n\t\tcase PrismicSpecialType.Document: {\n\t\t\tassertType<prismicT.PrismicDocument>(\n\t\t\t\tPrismicSpecialType.Document,\n\t\t\t\tnormalizers.isDocument,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.document({\n\t\t\t\t...config,\n\t\t\t\tvalue: config.value,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase PrismicSpecialType.DocumentData: {\n\t\t\tassertType<prismicT.PrismicDocument[\"data\"]>(\n\t\t\t\tPrismicSpecialType.DocumentData,\n\t\t\t\tnormalizers.isDocumentDataField,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.documentData({\n\t\t\t\t...config,\n\t\t\t\tvalue: config.value,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Group: {\n\t\t\tassertType<prismicT.GroupField>(\n\t\t\t\tprismicT.CustomTypeModelFieldType.Group,\n\t\t\t\tnormalizers.isGroupField,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.group({\n\t\t\t\t...config,\n\t\t\t\tvalue: config.value,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Slices: {\n\t\t\tassertType<prismicT.SliceZone>(\n\t\t\t\tprismicT.CustomTypeModelFieldType.Slices,\n\t\t\t\tnormalizers.isSlices,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.slices({\n\t\t\t\t...config,\n\t\t\t\tvalue: config.value,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelSliceType.Slice:\n\t\tcase PrismicSpecialType.SharedSliceVariation: {\n\t\t\tassertType<prismicT.Slice | prismicT.SharedSlice>(\n\t\t\t\tprismicT.CustomTypeModelSliceType.Slice,\n\t\t\t\tnormalizers.isSlice,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.slice({\n\t\t\t\t...config,\n\t\t\t\tvalue: config.value,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Link: {\n\t\t\tassertType<prismicT.LinkField>(\n\t\t\t\tprismicT.CustomTypeModelFieldType.Link,\n\t\t\t\tnormalizers.isLinkField,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.link({\n\t\t\t\tvalue: config.value,\n\t\t\t\tpath: config.path,\n\t\t\t\tgetNode: config.getNode,\n\t\t\t\tlinkResolver: config.linkResolver,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Image: {\n\t\t\tassertType<prismicT.ImageField>(\n\t\t\t\tprismicT.CustomTypeModelFieldType.Image,\n\t\t\t\tnormalizers.isImageField,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.image({\n\t\t\t\tvalue: config.value,\n\t\t\t\tpath: config.path,\n\t\t\t\timageImgixParams: config.imageImgixParams,\n\t\t\t\timagePlaceholderImgixParams: config.imagePlaceholderImgixParams,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.StructuredText: {\n\t\t\tassertType<StructuredTextField>(\n\t\t\t\tprismicT.CustomTypeModelFieldType.StructuredText,\n\t\t\t\tnormalizers.isStructuredTextField,\n\t\t\t\tconfig.value,\n\t\t\t);\n\n\t\t\treturn normalizers.structuredText({\n\t\t\t\tvalue: config.value,\n\t\t\t\tpath: config.path,\n\t\t\t\tlinkResolver: config.linkResolver,\n\t\t\t\thtmlSerializer: config.htmlSerializer,\n\t\t\t}) as NormalizedValue<Value>;\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn config.value as NormalizedValue<Value>;\n\t\t}\n\t}\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport {\n\tPrismicSpecialType,\n\tTransformFieldNameFn,\n\tTypePath,\n\tTypePathKind,\n} from \"../types\";\n\nconst fieldToTypePaths = <\n\tModel extends prismicT.CustomTypeModelField | prismicT.CustomTypeModelSlice,\n>(\n\tpath: string[],\n\tmodel: Model,\n\ttransformFieldName: TransformFieldNameFn,\n): TypePath[] => {\n\tswitch (model.type) {\n\t\tcase prismicT.CustomTypeModelFieldType.UID: {\n\t\t\treturn [];\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Group: {\n\t\t\tconst fields = Object.entries(model.config.fields).flatMap(\n\t\t\t\t([fieldId, fieldModel]) =>\n\t\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t\t[...path, transformFieldName(fieldId)],\n\t\t\t\t\t\tfieldModel,\n\t\t\t\t\t\ttransformFieldName,\n\t\t\t\t\t),\n\t\t\t);\n\n\t\t\treturn [{ kind: TypePathKind.Field, type: model.type, path }, ...fields];\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelFieldType.Slices: {\n\t\t\tconst choices = (\n\t\t\t\t(model.config.choices && Object.entries(model.config.choices)) ||\n\t\t\t\t[]\n\t\t\t)\n\t\t\t\t.filter(\n\t\t\t\t\t(entry): entry is [string, prismicT.CustomTypeModelSlice] =>\n\t\t\t\t\t\tentry[1].type === prismicT.CustomTypeModelSliceType.Slice,\n\t\t\t\t)\n\t\t\t\t.flatMap(([choiceId, choiceModel]) =>\n\t\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t\t[...path, choiceId],\n\t\t\t\t\t\tchoiceModel,\n\t\t\t\t\t\ttransformFieldName,\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\treturn [{ kind: TypePathKind.Field, type: model.type, path }, ...choices];\n\t\t}\n\n\t\tcase prismicT.CustomTypeModelSliceType.Slice: {\n\t\t\tconst primary = Object.entries(model[\"non-repeat\"] || {}).flatMap(\n\t\t\t\t([fieldId, fieldModel]) =>\n\t\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t\t[...path, \"primary\", transformFieldName(fieldId)],\n\t\t\t\t\t\tfieldModel,\n\t\t\t\t\t\ttransformFieldName,\n\t\t\t\t\t),\n\t\t\t);\n\n\t\t\tconst items = Object.entries(model.repeat || {}).flatMap(\n\t\t\t\t([fieldId, fieldModel]) =>\n\t\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t\t[...path, \"items\", transformFieldName(fieldId)],\n\t\t\t\t\t\tfieldModel,\n\t\t\t\t\t\ttransformFieldName,\n\t\t\t\t\t),\n\t\t\t);\n\n\t\t\treturn [\n\t\t\t\t{ kind: TypePathKind.Field, type: model.type, path },\n\t\t\t\t...primary,\n\t\t\t\t...items,\n\t\t\t];\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tkind: TypePathKind.Field,\n\t\t\t\t\tpath,\n\t\t\t\t\ttype: model.type,\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n};\n\nexport const customTypeModelToTypePaths = <\n\tModel extends prismicT.CustomTypeModel,\n>(\n\tcustomTypeModel: Model,\n\ttransformFieldName: TransformFieldNameFn,\n): TypePath[] => {\n\tconst definition = customTypeModel.json;\n\tconst fieldModels = Object.assign({}, ...Object.values(definition)) as Record<\n\t\tstring,\n\t\tprismicT.CustomTypeModelField\n\t>;\n\n\tconst hasDataFields =\n\t\tObject.values(fieldModels).filter(\n\t\t\t(fieldModel) => fieldModel.type !== prismicT.CustomTypeModelFieldType.UID,\n\t\t).length > 0;\n\n\tconst documentTypePath = {\n\t\tkind: TypePathKind.CustomType,\n\t\ttype: PrismicSpecialType.Document,\n\t\tpath: [customTypeModel.id],\n\t};\n\n\tif (hasDataFields) {\n\t\tconst data = Object.entries(fieldModels).flatMap(([fieldId, fieldModel]) =>\n\t\t\tfieldToTypePaths(\n\t\t\t\t[customTypeModel.id, \"data\", transformFieldName(fieldId)],\n\t\t\t\tfieldModel,\n\t\t\t\ttransformFieldName,\n\t\t\t),\n\t\t);\n\n\t\treturn [\n\t\t\tdocumentTypePath,\n\t\t\t{\n\t\t\t\tkind: TypePathKind.Field,\n\t\t\t\ttype: PrismicSpecialType.DocumentData,\n\t\t\t\tpath: [customTypeModel.id, \"data\"],\n\t\t\t},\n\t\t\t...data,\n\t\t];\n\t} else {\n\t\treturn [documentTypePath];\n\t}\n};\n\nexport const sharedSliceModelToTypePaths = <\n\tModel extends prismicT.SharedSliceModel,\n>(\n\tsharedSliceModel: Model,\n\ttransformFieldName: TransformFieldNameFn,\n): TypePath[] => {\n\treturn sharedSliceModel.variations.flatMap((variation) => {\n\t\tconst primary = Object.entries(variation.primary || {}).flatMap(\n\t\t\t([fieldId, fieldModel]) =>\n\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t[\n\t\t\t\t\t\tsharedSliceModel.id,\n\t\t\t\t\t\tvariation.id,\n\t\t\t\t\t\t\"primary\",\n\t\t\t\t\t\ttransformFieldName(fieldId),\n\t\t\t\t\t],\n\t\t\t\t\tfieldModel,\n\t\t\t\t\ttransformFieldName,\n\t\t\t\t),\n\t\t);\n\n\t\tconst items = Object.entries(variation.items || {}).flatMap(\n\t\t\t([fieldId, fieldModel]) =>\n\t\t\t\tfieldToTypePaths(\n\t\t\t\t\t[\n\t\t\t\t\t\tsharedSliceModel.id,\n\t\t\t\t\t\tvariation.id,\n\t\t\t\t\t\t\"items\",\n\t\t\t\t\t\ttransformFieldName(fieldId),\n\t\t\t\t\t],\n\t\t\t\t\tfieldModel,\n\t\t\t\t\ttransformFieldName,\n\t\t\t\t),\n\t\t);\n\n\t\treturn [\n\t\t\t{\n\t\t\t\tkind: TypePathKind.SharedSliceVariation,\n\t\t\t\ttype: PrismicSpecialType.SharedSliceVariation,\n\t\t\t\tpath: [sharedSliceModel.id, variation.id],\n\t\t\t},\n\t\t\t...primary,\n\t\t\t...items,\n\t\t];\n\t});\n};\n","export const serializePath = (path: string[]): string => path.join(\".\");\n","import { SerializedTypePath, TypePath } from \"../types\";\nimport { serializePath } from \"./serializePath\";\n\nexport const serializeTypePaths = (\n\ttypePaths: TypePath[],\n): SerializedTypePath[] => {\n\treturn typePaths.map((typePath) => {\n\t\treturn {\n\t\t\t...typePath,\n\t\t\tpath: serializePath(typePath.path),\n\t\t};\n\t});\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as imgixGatsby from \"@imgix/gatsby\";\nimport * as nodeHelpers from \"gatsby-node-helpers\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { SerializedTypePath, TransformFieldNameFn, TypePath } from \"../types\";\nimport { normalize } from \"./normalize\";\nimport {\n\tDEFAULT_IMGIX_PARAMS,\n\tDEFAULT_PLACEHOLDER_IMGIX_PARAMS,\n\tGLOBAL_TYPE_PREFIX,\n} from \"../constants\";\nimport { NormalizedValue } from \"./types\";\nimport { SetRequired } from \"type-fest\";\nimport {\n\tcustomTypeModelToTypePaths,\n\tsharedSliceModelToTypePaths,\n} from \"./typePaths\";\nimport { NormalizedDocumentValue } from \"./normalizers\";\nimport { serializeTypePaths } from \"./serializeTypePaths\";\nimport { serializePath } from \"./serializePath\";\n\n// `createNodeId` would normally create a hash from its input, but we can treat\n// it as an identity function since we are using it within the context of\n// Prismic documents with unique IDs.\nconst createNodeId = (input: string): string => input;\n\n// `createContentDigest` would normally create a hash from its input, but we\n// can treat it as a stubbed function since a Gatsby node's\n// `internal.contentDigest` property is an internal field. In a runtime\n// preview, we don't need the digest.\nconst createContentDigest = <T>(_input: T): string =>\n\t\"contentDigest is not supported during previews\";\n\nexport type RuntimeConfig = {\n\ttypePrefix?: string;\n\tlinkResolver?: prismicH.LinkResolverFunction;\n\timageImgixParams?: imgixGatsby.ImgixUrlParams;\n\timagePlaceholderImgixParams?: imgixGatsby.ImgixUrlParams;\n\thtmlSerializer?: prismicH.HTMLMapSerializer | prismicH.HTMLFunctionSerializer;\n\ttransformFieldName?: TransformFieldNameFn;\n};\n\ntype SubscriberFn = () => void;\n\nexport const createRuntime = (config: RuntimeConfig = {}): Runtime => {\n\treturn new Runtime(config);\n};\n\nexport class Runtime {\n\tnodes: NormalizedDocumentValue[];\n\ttypePaths: SerializedTypePath[];\n\tsubscribers: SubscriberFn[];\n\n\tconfig: SetRequired<\n\t\tRuntimeConfig,\n\t\t\"imageImgixParams\" | \"imagePlaceholderImgixParams\" | \"transformFieldName\"\n\t>;\n\n\tnodeHelpers: nodeHelpers.NodeHelpers;\n\n\tconstructor(config: RuntimeConfig = {}) {\n\t\tthis.nodes = [];\n\t\tthis.typePaths = [];\n\t\tthis.subscribers = [];\n\n\t\tthis.config = {\n\t\t\t...config,\n\t\t\timageImgixParams: config.imageImgixParams ?? DEFAULT_IMGIX_PARAMS,\n\t\t\timagePlaceholderImgixParams:\n\t\t\t\tconfig.imagePlaceholderImgixParams ?? DEFAULT_PLACEHOLDER_IMGIX_PARAMS,\n\t\t\ttransformFieldName:\n\t\t\t\tconfig.transformFieldName ??\n\t\t\t\t((fieldName: string) => fieldName.replace(/-/g, \"_\")),\n\t\t};\n\n\t\tthis.nodeHelpers = nodeHelpers.createNodeHelpers({\n\t\t\ttypePrefix: [GLOBAL_TYPE_PREFIX, config.typePrefix]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" \"),\n\t\t\tfieldPrefix: GLOBAL_TYPE_PREFIX,\n\t\t\tcreateNodeId,\n\t\t\tcreateContentDigest,\n\t\t});\n\t}\n\n\tsubscribe(callback: SubscriberFn): void {\n\t\tthis.subscribers = [...this.subscribers, callback];\n\t}\n\n\tunsubscribe(callback: SubscriberFn): void {\n\t\tthis.subscribers = this.subscribers.filter(\n\t\t\t(registeredCallback) => registeredCallback !== callback,\n\t\t);\n\t}\n\n\tregisterCustomTypeModel(\n\t\tmodel: prismicT.CustomTypeModel,\n\t): SerializedTypePath[] {\n\t\tconst typePaths = pipe(\n\t\t\tcustomTypeModelToTypePaths(model, this.config.transformFieldName),\n\t\t\tserializeTypePaths,\n\t\t);\n\n\t\tthis.typePaths = [...this.typePaths, ...typePaths];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn typePaths;\n\t}\n\n\tregisterCustomTypeModels(\n\t\tmodels: prismicT.CustomTypeModel[],\n\t): SerializedTypePath[] {\n\t\tconst typePaths = pipe(\n\t\t\tmodels.flatMap((model) =>\n\t\t\t\tcustomTypeModelToTypePaths(model, this.config.transformFieldName),\n\t\t\t),\n\t\t\tserializeTypePaths,\n\t\t);\n\n\t\tthis.typePaths = [...this.typePaths, ...typePaths];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn typePaths;\n\t}\n\n\tregisterSharedSliceModel(\n\t\tmodel: prismicT.SharedSliceModel,\n\t): SerializedTypePath[] {\n\t\tconst typePaths = pipe(\n\t\t\tsharedSliceModelToTypePaths(model, this.config.transformFieldName),\n\t\t\tserializeTypePaths,\n\t\t);\n\n\t\tthis.typePaths = [...this.typePaths, ...typePaths];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn typePaths;\n\t}\n\n\tregisterSharedSliceModels(\n\t\tmodels: prismicT.SharedSliceModel[],\n\t): SerializedTypePath[] {\n\t\tconst typePaths = pipe(\n\t\t\tmodels.flatMap((model) =>\n\t\t\t\tsharedSliceModelToTypePaths(model, this.config.transformFieldName),\n\t\t\t),\n\t\t\tserializeTypePaths,\n\t\t);\n\n\t\tthis.typePaths = [...this.typePaths, ...typePaths];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn typePaths;\n\t}\n\n\tregisterDocument<PrismicDocument extends prismicT.PrismicDocument>(\n\t\tdocument: PrismicDocument,\n\t): NormalizedDocumentValue<PrismicDocument> {\n\t\tconst normalizedDocument = this.normalizeDocument(document);\n\n\t\tthis.nodes = [...this.nodes, normalizedDocument];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn normalizedDocument;\n\t}\n\n\tregisterDocuments<PrismicDocument extends prismicT.PrismicDocument>(\n\t\tdocuments: PrismicDocument[],\n\t): NormalizedDocumentValue<PrismicDocument>[] {\n\t\tconst nodes = documents.map((document) => {\n\t\t\treturn this.normalizeDocument(document);\n\t\t});\n\n\t\tthis.nodes = [...this.nodes, ...nodes];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn nodes;\n\t}\n\n\tnormalizeDocument<PrismicDocument extends prismicT.PrismicDocument>(\n\t\tdocument: PrismicDocument,\n\t): NormalizedDocumentValue<PrismicDocument> {\n\t\treturn this.normalize(document, [\n\t\t\tdocument.type,\n\t\t]) as NormalizedDocumentValue<PrismicDocument>;\n\t}\n\n\tnormalize<Value>(value: Value, path: string[]): NormalizedValue<Value> {\n\t\treturn normalize({\n\t\t\tvalue,\n\t\t\tpath,\n\t\t\tgetNode: this.getNode.bind(this),\n\t\t\tgetTypePath: this.getTypePath.bind(this),\n\t\t\tnodeHelpers: this.nodeHelpers,\n\t\t\tlinkResolver: this.config.linkResolver,\n\t\t\thtmlSerializer: this.config.htmlSerializer,\n\t\t\timageImgixParams: this.config.imageImgixParams,\n\t\t\timagePlaceholderImgixParams: this.config.imagePlaceholderImgixParams,\n\t\t\ttransformFieldName: this.config.transformFieldName,\n\t\t});\n\t}\n\n\tgetNode<Document extends prismicT.PrismicDocument>(\n\t\tid: string,\n\t): NormalizedDocumentValue<Document> | undefined {\n\t\treturn this.nodes.find(\n\t\t\t(node): node is NormalizedDocumentValue<Document> =>\n\t\t\t\tnode.prismicId === id,\n\t\t);\n\t}\n\n\thasNode(id: string): boolean {\n\t\treturn this.nodes.some((node) => node.prismicId === id);\n\t}\n\n\tgetTypePath(path: string[]): SerializedTypePath | undefined {\n\t\treturn this.typePaths.find(\n\t\t\t(typePath) => typePath.path === serializePath(path),\n\t\t);\n\t}\n\n\texportTypePaths(): string {\n\t\treturn JSON.stringify(this.typePaths);\n\t}\n\n\timportTypePaths(typePathsExport: string): TypePath[] {\n\t\tconst importedTypePaths = JSON.parse(typePathsExport);\n\n\t\tthis.typePaths = [...this.typePaths, ...importedTypePaths];\n\n\t\tthis.#notifySubscribers();\n\n\t\treturn importedTypePaths;\n\t}\n\n\t#notifySubscribers(): void {\n\t\tfor (const subscriber of this.subscribers) {\n\t\t\tsubscriber();\n\t\t}\n\t}\n}\n","import * as gatsby from \"gatsby\";\nimport * as prismic from \"@prismicio/client\";\nimport * as gatsbyFs from \"gatsby-source-filesystem\";\nimport { createNodeHelpers } from \"gatsby-node-helpers\";\n\nimport { GLOBAL_TYPE_PREFIX } from \"./constants\";\nimport { Dependencies, PluginOptions } from \"./types\";\nimport { createRuntime } from \"./runtime\";\n\nconst defaultTransformFieldName = (fieldName: string) =>\n\tfieldName.replace(/-/g, \"_\");\n\n/**\n * Build the dependencies used by functions throughout the plugin.\n *\n * This collection of dependencies is shared through the use of the `fp-ts/Reader` monad.\n *\n * @param gatsbyContext - Arguments provided to Gatsby's Node APIs.\n * @param pluginOptions - The plugin instance's options.\n *\n * @returns Dependencies used throughout the plugin.\n * @see https://gcanti.github.io/fp-ts/modules/Reader.ts.html\n */\nexport const buildDependencies = async (\n\tgatsbyContext: gatsby.NodePluginArgs,\n\tpluginOptions: PluginOptions,\n): Promise<Dependencies> => {\n\tconst prismicClient = prismic.createClient(pluginOptions.apiEndpoint, {\n\t\tfetch: pluginOptions.fetch,\n\t\taccessToken: pluginOptions.accessToken,\n\t\troutes: pluginOptions.routes,\n\t\tdefaultParams: {\n\t\t\tlang: pluginOptions.lang,\n\t\t\tfetchLinks: pluginOptions.fetchLinks,\n\t\t\tgraphQuery: pluginOptions.graphQuery,\n\t\t\tpageSize: pluginOptions.pageSize,\n\t\t},\n\t});\n\n\tif (pluginOptions.releaseID) {\n\t\tprismicClient.queryContentFromReleaseByID(pluginOptions.releaseID);\n\t}\n\n\tconst transformFieldName =\n\t\tpluginOptions.transformFieldName || defaultTransformFieldName;\n\n\treturn {\n\t\tpluginOptions,\n\t\tprismicClient,\n\t\twebhookBody: gatsbyContext.webhookBody,\n\t\tcreateNode: gatsbyContext.actions.createNode,\n\t\tcreateTypes: gatsbyContext.actions.createTypes,\n\t\ttouchNode: gatsbyContext.actions.touchNode,\n\t\tdeleteNode: gatsbyContext.actions.deleteNode,\n\t\tcreateNodeId: gatsbyContext.createNodeId,\n\t\tcreateContentDigest: gatsbyContext.createContentDigest,\n\t\treporter: gatsbyContext.reporter,\n\t\treportInfo: gatsbyContext.reporter.info,\n\t\treportWarning: gatsbyContext.reporter.warn,\n\t\treportVerbose: gatsbyContext.reporter.verbose,\n\t\tbuildUnionType: gatsbyContext.schema.buildUnionType,\n\t\tbuildObjectType: gatsbyContext.schema.buildObjectType,\n\t\tbuildEnumType: gatsbyContext.schema.buildEnumType,\n\t\tbuildInterfaceType: gatsbyContext.schema.buildInterfaceType,\n\t\tbuildScalarType: gatsbyContext.schema.buildScalarType,\n\t\tgetNode: gatsbyContext.getNode,\n\t\tgetNodes: gatsbyContext.getNodes,\n\t\tschema: gatsbyContext.schema,\n\t\tstore: gatsbyContext.store,\n\t\tcache: gatsbyContext.cache,\n\t\tglobalNodeHelpers: createNodeHelpers({\n\t\t\ttypePrefix: GLOBAL_TYPE_PREFIX,\n\t\t\tcreateNodeId: gatsbyContext.createNodeId,\n\t\t\tcreateContentDigest: gatsbyContext.createContentDigest,\n\t\t}),\n\t\tnodeHelpers: createNodeHelpers({\n\t\t\ttypePrefix: [GLOBAL_TYPE_PREFIX, pluginOptions.typePrefix]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" \"),\n\t\t\tfieldPrefix: GLOBAL_TYPE_PREFIX,\n\t\t\tcreateNodeId: gatsbyContext.createNodeId,\n\t\t\tcreateContentDigest: gatsbyContext.createContentDigest,\n\t\t}),\n\t\tcreateRemoteFileNode:\n\t\t\tpluginOptions.createRemoteFileNode || gatsbyFs.createRemoteFileNode,\n\t\ttransformFieldName,\n\t\truntime: createRuntime({\n\t\t\ttypePrefix: GLOBAL_TYPE_PREFIX,\n\t\t\tlinkResolver: pluginOptions.linkResolver,\n\t\t\timageImgixParams: pluginOptions.imageImgixParams,\n\t\t\timagePlaceholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n\t\t\thtmlSerializer: pluginOptions.htmlSerializer,\n\t\t\ttransformFieldName,\n\t\t}),\n\t};\n};\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport * as T from \"fp-ts/Task\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe, constVoid } from \"fp-ts/function\";\n\nimport { createAllDocumentTypesType } from \"./lib/createAllDocumentTypesType\";\nimport { createCustomType } from \"./lib/createCustomType\";\nimport { createSharedSlice } from \"./lib/createSharedSlice\";\nimport { createTypePath } from \"./lib/createTypePath\";\nimport { createTypes } from \"./lib/createTypes\";\nimport { preparePluginOptions } from \"./lib/preparePluginOptions\";\nimport { throwError } from \"./lib/throwError\";\n\nimport { buildAlternateLanguageType } from \"./builders/buildAlternateLanguageType\";\nimport { buildEmbedType } from \"./builders/buildEmbedType\";\nimport { buildGeoPointType } from \"./builders/buildGeoPointType\";\nimport { buildImageDimensionsType } from \"./builders/buildImageDimensionsType\";\nimport { buildImageThumbnailType } from \"./builders/buildImageThumbnailType\";\nimport { buildImgixImageTypes } from \"./builders/buildImgixImageTypes\";\nimport { buildLinkType } from \"./builders/buildLinkType\";\nimport { buildLinkTypeEnumType } from \"./builders/buildLinkTypeEnumType\";\nimport { buildSharedSliceInterface } from \"./builders/buildSharedSliceInterface\";\nimport { buildSliceInterface } from \"./builders/buildSliceInterface\";\nimport { buildStructuredTextType } from \"./builders/buildStructuredTextType\";\nimport { buildTypePathType } from \"./builders/buildTypePathType\";\n\nimport { Dependencies, Mutable, UnpreparedPluginOptions } from \"./types\";\nimport { buildDependencies } from \"./buildDependencies\";\n\nconst GatsbyGraphQLTypeM = A.getMonoid<gatsby.GatsbyGraphQLType>();\n\n/**\n * Create general types used by other types. Some types are global (i.e. not\n * repository-specific), while others are repository-specific, depending on the\n * type's use of custom plugin options.\n */\nexport const createBaseTypes: RTE.ReaderTaskEither<Dependencies, never, void> =\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"baseTypes\", () =>\n\t\t\tpipe(\n\t\t\t\t[\n\t\t\t\t\tbuildAlternateLanguageType,\n\t\t\t\t\tbuildEmbedType,\n\t\t\t\t\tbuildGeoPointType,\n\t\t\t\t\tbuildImageDimensionsType,\n\t\t\t\t\tbuildImageThumbnailType,\n\t\t\t\t\tbuildLinkType,\n\t\t\t\t\tbuildLinkTypeEnumType,\n\t\t\t\t\tbuildSliceInterface,\n\t\t\t\t\tbuildSharedSliceInterface,\n\t\t\t\t\tbuildStructuredTextType,\n\t\t\t\t\tbuildTypePathType,\n\t\t\t\t],\n\t\t\t\tRTE.sequenceArray,\n\t\t\t),\n\t\t),\n\t\tRTE.bind(\"imgixTypes\", () => buildImgixImageTypes),\n\t\tRTE.map((scope) =>\n\t\t\tGatsbyGraphQLTypeM.concat(\n\t\t\t\tscope.baseTypes as Mutable<typeof scope.baseTypes>,\n\t\t\t\tscope.imgixTypes,\n\t\t\t),\n\t\t),\n\t\tRTE.chain(createTypes),\n\t\tRTE.map(constVoid),\n\t);\n\n/**\n * Create types for all Custom Types using the JSON models provided at\n * `pluginOptions.customTypeModels`.\n */\nconst createCustomTypes: RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgatsby.GatsbyGraphQLObjectType[]\n> = pipe(\n\tRTE.asks((deps: Dependencies) => deps.pluginOptions.customTypeModels),\n\tRTE.map(A.map(createCustomType)),\n\tRTE.chain(RTE.sequenceArray),\n\tRTE.map((types) => types as Mutable<typeof types>),\n);\n\n/**\n * Create types for all Shared Slices using the JSON models provided at\n * `pluginOptions.sharedSliceModels`.\n */\nconst createSharedSlices: RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tgatsby.GatsbyGraphQLUnionType[]\n> = pipe(\n\tRTE.asks((deps: Dependencies) => deps.pluginOptions.sharedSliceModels),\n\tRTE.map(A.map(createSharedSlice)),\n\tRTE.chain(RTE.sequenceArray),\n\tRTE.map((types) => types as Mutable<typeof types>),\n);\n\nconst createTypePaths: RTE.ReaderTaskEither<Dependencies, Error, void> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chainFirst((scope) =>\n\t\tRTE.right(\n\t\t\tscope.runtime.registerCustomTypeModels(\n\t\t\t\tscope.pluginOptions.customTypeModels,\n\t\t\t),\n\t\t),\n\t),\n\tRTE.chainFirst((scope) =>\n\t\tRTE.right(\n\t\t\tscope.runtime.registerSharedSliceModels(\n\t\t\t\tscope.pluginOptions.sharedSliceModels,\n\t\t\t),\n\t\t),\n\t),\n\tRTE.bind(\"typePaths\", (scope) => RTE.right(scope.runtime.typePaths)),\n\tRTE.chainFirstW((scope) =>\n\t\tpipe(scope.typePaths, A.map(createTypePath), RTE.sequenceArray),\n\t),\n\tRTE.map(constVoid),\n);\n\n/**\n * To be executed in the `createSchemaCustomization` API.\n */\nconst createSchemaCustomizationProgram: RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tvoid\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chainFirst(() => createBaseTypes),\n\tRTE.chainFirst(() => createSharedSlices),\n\tRTE.bind(\"customTypeTypes\", () => createCustomTypes),\n\tRTE.chainFirstW((scope) => createAllDocumentTypesType(scope.customTypeTypes)),\n\tRTE.chainFirst(() => createTypePaths),\n\tRTE.map(constVoid),\n);\n\n/**\n * Create all GraphQL types for the plugin's configured Prismic repository.\n *\n * @see https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#createSchemaCustomization\n */\nexport const createSchemaCustomization: NonNullable<\n\tgatsby.GatsbyNode[\"createSchemaCustomization\"]\n> = async (\n\tgatsbyContext: gatsby.CreateSchemaCustomizationArgs,\n\tunpreparedPluginOptions: UnpreparedPluginOptions,\n) => {\n\tconst pluginOptions = await preparePluginOptions(unpreparedPluginOptions);\n\tconst dependencies = await buildDependencies(gatsbyContext, pluginOptions);\n\n\treturn await pipe(\n\t\tcreateSchemaCustomizationProgram(dependencies),\n\t\tTE.fold(throwError, () => T.of(void 0)),\n\t)();\n};\n","import * as gatsby from \"gatsby\";\nimport * as prismic from \"@prismicio/client\";\nimport * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\nimport * as prismicCustomTypes from \"@prismicio/custom-types-client\";\nimport fetch from \"node-fetch\";\n\nimport { preparePluginOptions } from \"./lib/preparePluginOptions\";\nimport { sprintf } from \"./lib/sprintf\";\n\nimport { UnpreparedPluginOptions } from \"./types\";\nimport {\n\tFORBIDDEN_ACCESS_WITHOUT_ACCESS_TOKEN,\n\tFORBIDDEN_ACCESS_WITH_ACCESS_TOKEN,\n\tFORBIDDEN_CUSTOM_TYPES_API_ACCESS,\n\tMISSING_SCHEMAS_MSG,\n\tMISSING_SCHEMA_MSG,\n\tNON_EXISTENT_RELEASE_WITHOUT_ACCESS_TOKEN_MSG,\n\tNON_EXISTENT_RELEASE_WITH_ACCESS_TOKEN_MSG,\n\tREPORTER_TEMPLATE,\n} from \"./constants\";\n\nexport const pluginOptionsSchema: NonNullable<\n\tgatsby.GatsbyNode[\"pluginOptionsSchema\"]\n> = (args) => {\n\tconst { Joi } = args;\n\n\treturn Joi.object({\n\t\trepositoryName: Joi.string().required(),\n\t\taccessToken: Joi.string(),\n\t\tapiEndpoint: Joi.string(),\n\t\tcustomTypesApiToken: Joi.string(),\n\t\tcustomTypesApiEndpoint: Joi.string(),\n\t\treleaseID: Joi.string(),\n\t\tfetchLinks: Joi.array().items(Joi.string().required()),\n\t\tgraphQuery: Joi.string(),\n\t\tlang: Joi.string(),\n\t\tpageSize: Joi.number(),\n\t\tlinkResolver: Joi.function(),\n\t\troutes: Joi.array().items(\n\t\t\tJoi.object({\n\t\t\t\ttype: Joi.string().required(),\n\t\t\t\tpath: Joi.string().required(),\n\t\t\t\tresolvers: Joi.object().pattern(Joi.string(), Joi.string().required()),\n\t\t\t}),\n\t\t),\n\t\thtmlSerializer: Joi.alternatives(\n\t\t\tJoi.object().pattern(\n\t\t\t\tJoi.allow(...Object.keys(prismicH.Element)),\n\t\t\t\tJoi.function(),\n\t\t\t),\n\t\t\tJoi.function(),\n\t\t),\n\t\tschemas: Joi.object(),\n\t\tcustomTypeModels: Joi.array().items(\n\t\t\tJoi.object({\n\t\t\t\tid: Joi.string().required(),\n\t\t\t\tjson: Joi.object().required(),\n\t\t\t}).unknown(),\n\t\t),\n\t\tsharedSliceModels: Joi.array().items(\n\t\t\tJoi.object({\n\t\t\t\tid: Joi.string().required(),\n\t\t\t\tvariations: Joi.array()\n\t\t\t\t\t.items(\n\t\t\t\t\t\tJoi.object({\n\t\t\t\t\t\t\tid: Joi.string().required(),\n\t\t\t\t\t\t\tprimary: Joi.object(),\n\t\t\t\t\t\t\titems: Joi.object(),\n\t\t\t\t\t\t}).unknown(),\n\t\t\t\t\t)\n\t\t\t\t\t.required(),\n\t\t\t}).unknown(),\n\t\t),\n\t\timageImgixParams: Joi.object(),\n\t\timagePlaceholderImgixParams: Joi.object(),\n\t\ttypePrefix: Joi.string(),\n\t\twebhookSecret: Joi.string(),\n\t\tshouldDownloadFiles: Joi.alternatives(\n\t\t\tJoi.boolean(),\n\t\t\tJoi.function(),\n\t\t\tJoi.object().pattern(\n\t\t\t\tJoi.string(),\n\t\t\t\tJoi.alternatives(Joi.boolean(), Joi.function()),\n\t\t\t),\n\t\t),\n\t\tcreateRemoteFileNode: Joi.function(),\n\t\ttransformFieldName: Joi.function(),\n\t\tfetch: Joi.function(),\n\t})\n\t\t.or(\"customTypesApiToken\", \"customTypeModels\", \"schemas\")\n\t\t.oxor(\"fetchLinks\", \"graphQuery\")\n\t\t.external(async (unpreparedPluginOptions: UnpreparedPluginOptions) => {\n\t\t\tconst endpoint =\n\t\t\t\tunpreparedPluginOptions.apiEndpoint ||\n\t\t\t\tprismic.getEndpoint(unpreparedPluginOptions.repositoryName);\n\t\t\tconst client = prismic.createClient(endpoint, {\n\t\t\t\tfetch: unpreparedPluginOptions.fetch || fetch,\n\t\t\t\taccessToken: unpreparedPluginOptions.accessToken,\n\t\t\t});\n\n\t\t\tif (unpreparedPluginOptions.releaseID) {\n\t\t\t\tclient.queryContentFromReleaseByID(unpreparedPluginOptions.releaseID);\n\t\t\t}\n\n\t\t\tlet repository: prismicT.Repository | undefined;\n\n\t\t\t// Check access to the repository and, if given, the Release\n\t\t\ttry {\n\t\t\t\trepository = await client.getRepository();\n\t\t\t\tawait client.get({ pageSize: 1 });\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\tlet message = sprintf(\n\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\tunpreparedPluginOptions.repositoryName,\n\t\t\t\t\t\terror.message,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (error instanceof prismic.ForbiddenError || prismic.PrismicError) {\n\t\t\t\t\t\tmessage = sprintf(\n\t\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\t\tunpreparedPluginOptions.repositoryName,\n\t\t\t\t\t\t\tunpreparedPluginOptions.accessToken\n\t\t\t\t\t\t\t\t? FORBIDDEN_ACCESS_WITH_ACCESS_TOKEN\n\t\t\t\t\t\t\t\t: FORBIDDEN_ACCESS_WITHOUT_ACCESS_TOKEN,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tunpreparedPluginOptions.releaseID &&\n\t\t\t\t\t\t/ref could not be found/i.test(error.message)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmessage = sprintf(\n\t\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\t\tunpreparedPluginOptions.repositoryName,\n\t\t\t\t\t\t\tunpreparedPluginOptions.accessToken\n\t\t\t\t\t\t\t\t? sprintf(\n\t\t\t\t\t\t\t\t\t\tNON_EXISTENT_RELEASE_WITH_ACCESS_TOKEN_MSG,\n\t\t\t\t\t\t\t\t\t\tunpreparedPluginOptions.releaseID,\n\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t: sprintf(\n\t\t\t\t\t\t\t\t\t\tNON_EXISTENT_RELEASE_WITHOUT_ACCESS_TOKEN_MSG,\n\t\t\t\t\t\t\t\t\t\tunpreparedPluginOptions.releaseID,\n\t\t\t\t\t\t\t\t  ),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Joi.ValidationError(message, [{ message }], error.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check access to the Custom Types API if a token is given\n\t\t\tif (unpreparedPluginOptions.customTypesApiToken) {\n\t\t\t\tconst customTypesClient = prismicCustomTypes.createClient({\n\t\t\t\t\trepositoryName: unpreparedPluginOptions.repositoryName,\n\t\t\t\t\tendpoint: unpreparedPluginOptions.customTypesApiEndpoint,\n\t\t\t\t\ttoken: unpreparedPluginOptions.customTypesApiToken,\n\t\t\t\t\tfetch: unpreparedPluginOptions.fetch || fetch,\n\t\t\t\t});\n\n\t\t\t\ttry {\n\t\t\t\t\tawait customTypesClient.getAll();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t\tlet message = sprintf(\n\t\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\t\tunpreparedPluginOptions.repositoryName,\n\t\t\t\t\t\t\terror.message,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (error instanceof prismicCustomTypes.ForbiddenError) {\n\t\t\t\t\t\t\tmessage = sprintf(\n\t\t\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\t\t\tunpreparedPluginOptions.repositoryName,\n\t\t\t\t\t\t\t\tFORBIDDEN_CUSTOM_TYPES_API_ACCESS,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Joi.ValidationError(message, [{ message }], error.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if all Custom Type models have been provided\n\t\t\t// only if a Custom Types API token is not proided. If\n\t\t\t// a token is provided, we can assume we have all\n\t\t\t// needed Custom Types.\n\t\t\tif (!unpreparedPluginOptions.customTypesApiToken) {\n\t\t\t\tconst pluginOptions = await preparePluginOptions(\n\t\t\t\t\tunpreparedPluginOptions,\n\t\t\t\t);\n\n\t\t\t\tif (repository) {\n\t\t\t\t\tconst missingCustomTypeIds = Object.keys(repository.types).filter(\n\t\t\t\t\t\t(customTypeId) => {\n\t\t\t\t\t\t\treturn !pluginOptions.customTypeModels.some(\n\t\t\t\t\t\t\t\t(customTypeModel) => customTypeModel.id === customTypeId,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\tif (missingCustomTypeIds.length > 0) {\n\t\t\t\t\t\tthrow new Joi.ValidationError(\n\t\t\t\t\t\t\tMISSING_SCHEMAS_MSG,\n\t\t\t\t\t\t\tmissingCustomTypeIds.map((id) => ({\n\t\t\t\t\t\t\t\tmessage: sprintf(\n\t\t\t\t\t\t\t\t\tREPORTER_TEMPLATE,\n\t\t\t\t\t\t\t\t\tpluginOptions.repositoryName,\n\t\t\t\t\t\t\t\t\tsprintf(MISSING_SCHEMA_MSG, id),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\tpluginOptions.customTypeModels.map(\n\t\t\t\t\t\t\t\t(customTypeModel) => customTypeModel.id,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n};\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as I from \"fp-ts/Identity\";\nimport { pipe } from \"fp-ts/function\";\nimport { IdentifiableRecord } from \"gatsby-node-helpers\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Creates a node using the environment's `createNode` function.\n *\n * By using this function, the record's `id` field must be globally unique. If\n * the record's ID may conflict with another's within the application's scope,\n * even if it is of a different type, use the standard `createNodeOfType`\n * function instead.\n *\n * @param record - Record with an `id` field with which to create a node.\n * @param type - Type of the record.\n */\nexport const createGloballyUniqueNodeOfType = (\n\trecord: IdentifiableRecord,\n\ttype: string | string[],\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.NodeInput> =>\n\tRTE.asks((deps) =>\n\t\tpipe(\n\t\t\trecord,\n\t\t\tdeps.nodeHelpers.createNodeFactory(type, { idIsGloballyUnique: true }),\n\t\t\tI.chainFirst(deps.createNode),\n\t\t),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { IdentifiableRecord } from \"gatsby-node-helpers\";\n\nimport { Dependencies } from \"../types\";\n\nimport { createGloballyUniqueNodeOfType } from \"./createGloballyUniqueNodeOfType\";\n\nexport interface IdentifiableRecordWithType extends IdentifiableRecord {\n\ttype: string;\n}\n\n/**\n * Creates a node using the environment's `createNode` function. The provided\n * record is passed through a node helper factory based on the record's `type` field.\n *\n * By using this function, the record's `id` field must be globally unique. If\n * the record's ID may conflict with another's within the application's scope,\n * even if it is of a different type, use the standard `createNode` function instead.\n *\n * @param record - Record with an `id` and `type` field with which to create a node.\n * @see `lib/createNode.ts`\n */\nexport const createGloballyUniqueNode = (\n\trecord: IdentifiableRecordWithType,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.NodeInput> =>\n\tcreateGloballyUniqueNodeOfType(record, record.type);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { createGloballyUniqueNode } from \"./createGloballyUniqueNode\";\n\n/**\n * Creates one or more globally unique nodes.\n *\n * By using this function, the records' `id` fields must be globally unique. If\n * a record's ID may conflict with another's within the application's scope,\n * even if it is of a different type, use the standard `createNodes` function instead.\n *\n * @see lib/createGloballyUniqueNode.ts\n */\nexport const createGloballyUniqueNodes = flow(\n\tA.map(createGloballyUniqueNode),\n\tRTE.sequenceArray,\n);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, TypePathKind, TypePathNode } from \"../types\";\nimport { serializePath } from \"../runtime/serializePath\";\n\nimport { dotPath } from \"./dotPath\";\n\n/**\n * Returns a `TypePath` node for a given path using the environment's `getNode` function.\n *\n * @param path - Path used as a key to find a matching TypePath node.\n *\n * @returns The TypePath with the given key, if available.\n */\nexport const getTypePath = (\n\tkind: TypePathKind,\n\tpath: string[],\n): RTE.ReaderTaskEither<Dependencies, Error, TypePathNode> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"nodeId\", (scope) =>\n\t\t\tRTE.right(\n\t\t\t\tscope.nodeHelpers.createNodeId([\"TypePathType\", serializePath(path)]),\n\t\t\t),\n\t\t),\n\t\tRTE.chain((scope) =>\n\t\t\tRTE.fromIO(() => scope.getNode(scope.nodeId) as TypePathNode),\n\t\t),\n\t\tRTE.filterOrElse(\n\t\t\t(result) => result != null,\n\t\t\t() =>\n\t\t\t\tnew Error(\n\t\t\t\t\t`Could not find a \"${kind}\" type path for path: \"${dotPath(path)}\"`,\n\t\t\t\t),\n\t\t),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\nimport { dotPath } from \"./dotPath\";\n\ntype ShouldDownloadFileConfig = {\n\tpath: string[];\n\tfield: prismicT.ImageFieldImage | prismicT.LinkToMediaField;\n};\n\nexport const shouldDownloadFile = (\n\tconfig: ShouldDownloadFileConfig,\n): RTE.ReaderTaskEither<Dependencies, never, boolean> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bindW(\"predicate\", (scope) => {\n\t\t\tconst { shouldDownloadFiles } = scope.pluginOptions;\n\t\t\tconst fieldPath = dotPath(config.path);\n\n\t\t\tswitch (typeof shouldDownloadFiles) {\n\t\t\t\tcase \"boolean\": {\n\t\t\t\t\treturn RTE.right(() => shouldDownloadFiles);\n\t\t\t\t}\n\n\t\t\t\tcase \"function\": {\n\t\t\t\t\treturn RTE.right(shouldDownloadFiles);\n\t\t\t\t}\n\n\t\t\t\tcase \"object\": {\n\t\t\t\t\tconst fieldPredicate = shouldDownloadFiles[fieldPath];\n\n\t\t\t\t\tif (fieldPredicate) {\n\t\t\t\t\t\tif (typeof fieldPredicate === \"boolean\") {\n\t\t\t\t\t\t\treturn RTE.right(() => fieldPredicate);\n\t\t\t\t\t\t} else if (typeof fieldPredicate === \"function\") {\n\t\t\t\t\t\t\treturn RTE.right(fieldPredicate);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn RTE.right(() => false);\n\t\t}),\n\t\tRTE.map((scope) => scope.predicate(config.field)),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Returns a value from the environment's `cache` with the given key.\n *\n * @param key - Key used to get data from the cache.\n *\n * @returns Data from the cache with the given key, if available.\n */\nexport const getFromCache = <T>(\n\tkey: string,\n): RTE.ReaderTaskEither<Dependencies, Error, T> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) => RTE.fromTask(() => deps.cache.get(key) as Promise<T>)),\n\t\tRTE.chainW(\n\t\t\tRTE.fromPredicate(\n\t\t\t\t(result) => result != null,\n\t\t\t\t() => new Error(\"Cache does not contain a value for the given key\"),\n\t\t\t),\n\t\t),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Sets a value to the environment's `cache` with the given key.\n *\n * @param key - Key to identify a value in the cache.\n *\n * @returns A function that accepts a value to set to the environment's `cache`\n *   with the given key.\n */\nexport const setToCache =\n\t<T>(key: string) =>\n\t(value: T): RTE.ReaderTaskEither<Dependencies, never, T> =>\n\t\tpipe(\n\t\t\tRTE.ask<Dependencies>(),\n\t\t\tRTE.chain((deps) => RTE.fromTask(() => deps.cache.set(key, value))),\n\t\t\tRTE.map(() => value),\n\t\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\nimport { getFromCache } from \"./getFromCache\";\nimport { setToCache } from \"./setToCache\";\n\n/**\n * Get value from the cache using a given key. If a value for the given key does\n * not exist, set it with a given value.\n *\n * @param key - Key used to get data from the cache.\n * @param f - Function to compute the cached value if a value does not already exist.\n *\n * @returns Data from the cache with the given key.\n */\nexport const getFromOrSetToCache = <T>(\n\tkey: string,\n\tf: RTE.ReaderTaskEither<Dependencies, Error, T>,\n): RTE.ReaderTaskEither<Dependencies, Error, T> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain(() => getFromCache<T>(key)),\n\t\tRTE.orElse(() => pipe(f, RTE.chainFirstW(setToCache(key)))),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Touches a node using the environment's `touchNode` function.\n *\n * @param nodeId - ID of the node to touch.\n */\nexport const touchNode = (\n\tnode: gatsby.Node,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) => deps.touchNode(node));\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { REPORTER_TEMPLATE } from \"../constants\";\nimport { sprintf } from \"./sprintf\";\n\n/**\n * Reports a piece of text at the \"verbose\" importance level using the\n * environment's `reportVerbose` function.\n *\n * @param text - Text to report.\n */\nexport const reportVerbose = (\n\ttext: string,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) =>\n\t\tpipe(\n\t\t\tsprintf(REPORTER_TEMPLATE, deps.pluginOptions.repositoryName, text),\n\t\t\tdeps.reportVerbose,\n\t\t),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as gatsbyFs from \"gatsby-source-filesystem\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { shouldDownloadFile } from \"./shouldDownloadFile\";\nimport { getFromOrSetToCache } from \"./getFromOrSetToCache\";\nimport { touchNode } from \"./touchNode\";\nimport { reportVerbose } from \"./reportVerbose\";\n\ntype CreateRemoteFileNodeConfig = {\n\turl: string;\n\tfield: prismicT.ImageFieldImage | prismicT.LinkToMediaField;\n\tpath: string[];\n};\n\n/**\n * Creates a File node with remote data using the environment's\n * `createRemoteFileNode` function. The contents of the provided URL are\n * attached to the node's data.\n *\n * @param url - URL from which data is fetched.\n *\n * @returns The created File node.\n */\nexport const createRemoteFileNode = (\n\tconfig: CreateRemoteFileNodeConfig,\n): RTE.ReaderTaskEither<Dependencies, Error, gatsbyFs.FileSystemNode | null> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"attemptDownload\", () =>\n\t\t\tshouldDownloadFile({\n\t\t\t\tpath: config.path,\n\t\t\t\tfield: config.field,\n\t\t\t}),\n\t\t),\n\t\tRTE.chainFirst((scope) =>\n\t\t\tscope.attemptDownload\n\t\t\t\t? reportVerbose(`Attempting to download and cache file: ${config.url}`)\n\t\t\t\t: RTE.right(void 0),\n\t\t),\n\t\tRTE.chain((scope) =>\n\t\t\tgetFromOrSetToCache(\n\t\t\t\t`file-node-${config.url}`,\n\t\t\t\tRTE.fromTaskEither(\n\t\t\t\t\tTE.tryCatch(\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tscope.attemptDownload\n\t\t\t\t\t\t\t\t? scope.createRemoteFileNode({\n\t\t\t\t\t\t\t\t\t\turl: config.url,\n\t\t\t\t\t\t\t\t\t\tstore: scope.store,\n\t\t\t\t\t\t\t\t\t\tcache: scope.cache,\n\t\t\t\t\t\t\t\t\t\tcreateNode: scope.createNode,\n\t\t\t\t\t\t\t\t\t\tcreateNodeId: scope.createNodeId,\n\t\t\t\t\t\t\t\t\t\treporter: scope.reporter,\n\t\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t\t: Promise.resolve(null),\n\t\t\t\t\t\t(e) => e as Error,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tRTE.chainFirst((node) => (node ? touchNode(node) : RTE.right(null))),\n\t);\n","/**\n * Removes a URL parameter from a given URL.\n *\n * @param url - URL to modify.\n * @param paramKey - Key of the URL parameter to remove.\n *\n * @returns `url` without the `paramKey` URL parameter.\n */\nexport const removeURLParameter = (url: string, paramKey: string) => {\n\tconst instance = new URL(url);\n\n\tinstance.searchParams.delete(paramKey);\n\n\treturn instance.toString();\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as R from \"fp-ts/Record\";\nimport * as O from \"fp-ts/Option\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe } from \"fp-ts/function\";\nimport { Stringable } from \"gatsby-node-helpers\";\n\nimport {\n\tDependencies,\n\tPrismicSpecialType,\n\tTypePathKind,\n\tUnknownRecord,\n} from \"../types\";\n\nimport { getTypePath } from \"./getTypePath\";\nimport { createNodeOfType } from \"./createNodeOfType\";\nimport { mapRecordIndices } from \"./mapRecordIndices\";\nimport { createRemoteFileNode } from \"./createRemoteFileNode\";\nimport { PRISMIC_API_IMAGE_FIELDS } from \"../constants\";\nimport { removeURLParameter } from \"./removeAutoURLParameter\";\n\n/**\n * Determines if a value is a record.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a record, `false` otherwise.\n */\nconst unknownRecordRefinement = (value: unknown): value is UnknownRecord =>\n\ttypeof value === \"object\" && value !== null && !Array.isArray(value);\n\n/**\n * Determines if a value is an array of records.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is an array of records, `false` otherwise.\n */\nconst unknownRecordArrayValueRefinement = (\n\tvalue: unknown,\n): value is UnknownRecord[] =>\n\tArray.isArray(value) && value.every(unknownRecordRefinement);\n\n/**\n * Determines if a value is a Prismic document.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a Prismic document, `false` otherwise.\n */\nconst documentRefinement = (\n\tvalue: unknown,\n): value is prismicT.PrismicDocument =>\n\tunknownRecordRefinement(value) && \"first_publication_date\" in value;\n\n/**\n * Determines if a value is an Embed field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is an Embed field, `false` otherwise.\n */\nconst embedValueRefinement = (value: unknown): value is prismicT.EmbedField =>\n\tunknownRecordRefinement(value) && \"embed_url\" in value;\n\n/**\n * Determines if a value is a Slice.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a Slice, `false` otherwise.\n */\nconst sliceValueRefinement = (value: unknown): value is prismicT.Slice =>\n\tunknownRecordRefinement(value) && \"slice_type\" in value;\n\n/**\n * Determines if a value is a Slice.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a Slice, `false` otherwise.\n */\nconst sharedSliceValueRefinement = (\n\tvalue: unknown,\n): value is prismicT.SharedSlice =>\n\tsliceValueRefinement(value) && \"variation\" in value;\n\n/**\n * Determines if a value is a Slice Zone.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a Slice Zone, `false` otherwise.\n */\nconst slicesValueRefinement = (value: unknown): value is prismicT.SliceZone =>\n\tArray.isArray(value) && value.every(sliceValueRefinement);\n\n/**\n * Determines if the value is Stringable (has a `toString()` method).\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is Stringable, `false` otherwise.\n */\nconst stringableRefinement = (value: unknown): value is Stringable =>\n\t(typeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"bigint\" ||\n\t\ttypeof value === \"string\" ||\n\t\ttypeof value === \"symbol\" ||\n\t\ttypeof value === \"function\" ||\n\t\ttypeof value === \"object\") &&\n\tvalue != null &&\n\tBoolean(value.toString);\n\n/**\n * Determines if a value is a Link field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is a Link, `false` otherwise.\n */\nexport const linkValueRefinement = (\n\tvalue: unknown,\n): value is prismicT.LinkField => {\n\treturn typeof value === \"object\" && (value === null || \"link_type\" in value);\n};\n\n/**\n * Determines if a value is an Image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if the value is an Image, `false` otherwise.\n */\nexport const imageValueRefinement = (\n\tvalue: unknown,\n): value is prismicT.ImageField => {\n\t// Unfortunately, we can't check for specific properties here since it's\n\t// possible for the object to be empty if an image was never set.\n\treturn typeof value === \"object\" && value !== null;\n};\n\n/**\n * Normalizes a record within a Prismic document. It normalizes each field individually.\n *\n * @param path - Path to the record.\n * @param value - The record to normalize.\n *\n * @returns A normalized version of `value`.\n */\nconst normalizeDocumentRecord = (\n\tkind: TypePathKind,\n\tpath: string[],\n\tvalue: UnknownRecord,\n): RTE.ReaderTaskEither<Dependencies, never, UnknownRecord> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\tvalue,\n\t\t\t\tmapRecordIndices(deps.transformFieldName),\n\t\t\t\tR.mapWithIndex((prop, propValue) =>\n\t\t\t\t\tnormalizeDocumentSubtree(kind, [...path, prop], propValue),\n\t\t\t\t),\n\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t),\n\t\t),\n\t);\n\n/**\n * Traverses a subtree from a Prismic document and normalizes values as needed.\n * This function may process the subtree recursively.\n *\n * @param path - Path to the subtree.\n * @param value - The subtree to normalize.\n *\n * @returns A normalized version of `value`.\n */\nexport const normalizeDocumentSubtree = (\n\tkind: TypePathKind,\n\tpath: string[],\n\tvalue: unknown,\n): RTE.ReaderTaskEither<Dependencies, never, unknown> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bind(\"typePath\", () => getTypePath(kind, path)),\n\t\tRTE.bind(\"type\", (env) => RTE.right(env.typePath.type)),\n\t\tRTE.chain((env) => {\n\t\t\tswitch (env.typePath.type) {\n\t\t\t\tcase PrismicSpecialType.Document: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tdocumentRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bind(\"dataField\", (scope) =>\n\t\t\t\t\t\t\t!R.isEmpty(scope.value.data)\n\t\t\t\t\t\t\t\t? normalizeDocumentRecord(\n\t\t\t\t\t\t\t\t\t\tTypePathKind.CustomType,\n\t\t\t\t\t\t\t\t\t\t[...path, \"data\"],\n\t\t\t\t\t\t\t\t\t\tscope.value.data,\n\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t: RTE.right(undefined),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW((scope) =>\n\t\t\t\t\t\t\tRTE.right({\n\t\t\t\t\t\t\t\t...scope.value,\n\t\t\t\t\t\t\t\tdata: scope.dataField,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase PrismicSpecialType.DocumentData: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tunknownRecordRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW((value) =>\n\t\t\t\t\t\t\tnormalizeDocumentRecord(TypePathKind.Field, path, value),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Group: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tunknownRecordArrayValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map(\n\t\t\t\t\t\t\tA.map((item) =>\n\t\t\t\t\t\t\t\tnormalizeDocumentRecord(TypePathKind.Field, path, item),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW(RTE.sequenceArray),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Slices: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tslicesValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map(\n\t\t\t\t\t\t\tA.map((item) =>\n\t\t\t\t\t\t\t\tsharedSliceValueRefinement(item)\n\t\t\t\t\t\t\t\t\t? normalizeDocumentSubtree(\n\t\t\t\t\t\t\t\t\t\t\tTypePathKind.SharedSliceVariation,\n\t\t\t\t\t\t\t\t\t\t\t[item.slice_type, item.variation],\n\t\t\t\t\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: normalizeDocumentSubtree(\n\t\t\t\t\t\t\t\t\t\t\tTypePathKind.Field,\n\t\t\t\t\t\t\t\t\t\t\t[...path, item.slice_type],\n\t\t\t\t\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\t\t\t  ),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW(RTE.sequenceArray),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelSliceType.Slice: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tsliceValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bindW(\"primary\", (scope) =>\n\t\t\t\t\t\t\tnormalizeDocumentRecord(\n\t\t\t\t\t\t\t\tTypePathKind.Field,\n\t\t\t\t\t\t\t\t[...path, \"primary\"],\n\t\t\t\t\t\t\t\tscope.value.primary,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindW(\"items\", (scope) =>\n\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\tscope.value.items,\n\t\t\t\t\t\t\t\tA.map((item) =>\n\t\t\t\t\t\t\t\t\tnormalizeDocumentRecord(\n\t\t\t\t\t\t\t\t\t\tTypePathKind.Field,\n\t\t\t\t\t\t\t\t\t\t[...path, \"items\"],\n\t\t\t\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.sequenceArray,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map((scope) => ({\n\t\t\t\t\t\t\t...scope.value,\n\t\t\t\t\t\t\tprimary: scope.primary,\n\t\t\t\t\t\t\titems: scope.items,\n\t\t\t\t\t\t})),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase PrismicSpecialType.SharedSliceVariation: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tsharedSliceValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bindW(\"primary\", (scope) =>\n\t\t\t\t\t\t\tnormalizeDocumentRecord(\n\t\t\t\t\t\t\t\tTypePathKind.Field,\n\t\t\t\t\t\t\t\t[...path, \"primary\"],\n\t\t\t\t\t\t\t\tscope.value.primary,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindW(\"items\", (scope) =>\n\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\tscope.value.items,\n\t\t\t\t\t\t\t\tA.map((item) =>\n\t\t\t\t\t\t\t\t\tnormalizeDocumentRecord(\n\t\t\t\t\t\t\t\t\t\tTypePathKind.Field,\n\t\t\t\t\t\t\t\t\t\t[...path, \"items\"],\n\t\t\t\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.sequenceArray,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map((scope) => ({\n\t\t\t\t\t\t\t...scope.value,\n\t\t\t\t\t\t\tprimary: scope.primary,\n\t\t\t\t\t\t\titems: scope.items,\n\t\t\t\t\t\t})),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Embed: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tembedValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bind(\"id\", (scope) =>\n\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\tR.lookup(\"embed_url\", scope.value),\n\t\t\t\t\t\t\t\tRTE.fromOption(\n\t\t\t\t\t\t\t\t\t() => new Error(\"Embed URL field does not exist\"),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.filterOrElse(\n\t\t\t\t\t\t\t\t\t(url): url is string => typeof url === \"string\",\n\t\t\t\t\t\t\t\t\t() => new Error(\"Embed URL field is not a string\"),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.map(env.nodeHelpers.createNodeId),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW((scope) =>\n\t\t\t\t\t\t\t// This type name matches the method used in\n\t\t\t\t\t\t\t// `buildEmbedFieldConfig`.\n\t\t\t\t\t\t\tcreateNodeOfType({ ...scope.value, id: scope.id }, \"EmbedType\"),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map((node) => node.id),\n\t\t\t\t\t\tRTE.orElseW(() => RTE.right(null)),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.IntegrationFields: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tunknownRecordRefinement,\n\t\t\t\t\t\t\t() => new Error(\"Field value is not a plain object\"),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bind(\"id\", (scope) =>\n\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\tscope.value,\n\t\t\t\t\t\t\t\tR.lookup(\"id\"),\n\t\t\t\t\t\t\t\tO.filter(stringableRefinement),\n\t\t\t\t\t\t\t\tO.getOrElseW(() => env.createContentDigest(scope.value)),\n\t\t\t\t\t\t\t\t(id) => RTE.right(id),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.chainW((scope) =>\n\t\t\t\t\t\t\tcreateNodeOfType({ ...scope.value, id: scope.id }, [\n\t\t\t\t\t\t\t\t...path,\n\t\t\t\t\t\t\t\t\"IntegrationType\",\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.map((node) => node.id),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Link: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\tlinkValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bind(\"fileNode\", (scope) => {\n\t\t\t\t\t\t\treturn scope.value.link_type == prismicT.LinkType.Media &&\n\t\t\t\t\t\t\t\t\"url\" in scope.value &&\n\t\t\t\t\t\t\t\tscope.value.url\n\t\t\t\t\t\t\t\t? createRemoteFileNode({\n\t\t\t\t\t\t\t\t\t\turl: scope.value.url,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\tfield: scope.value,\n\t\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t\t: RTE.right(null);\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tRTE.map((scope) => ({\n\t\t\t\t\t\t\t...scope.value,\n\t\t\t\t\t\t\tlocalFile: scope.fileNode?.id || null,\n\t\t\t\t\t\t})),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Image: {\n\t\t\t\t\treturn pipe(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tRTE.fromPredicate(\n\t\t\t\t\t\t\timageValueRefinement,\n\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Field value does not match the type declared in its type path: ${env.type}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bindTo(\"value\"),\n\t\t\t\t\t\tRTE.bind(\"thumbnails\", (scope) =>\n\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\tscope.value,\n\t\t\t\t\t\t\t\tR.filterWithIndex<string, prismicT.ImageFieldImage>(\n\t\t\t\t\t\t\t\t\t(key) => !PRISMIC_API_IMAGE_FIELDS.includes(key),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.right,\n\t\t\t\t\t\t\t\tRTE.bindTo(\"thumbnails\"),\n\t\t\t\t\t\t\t\tRTE.bind(\"thumbnailFileNodes\", (thumbnailsScope) =>\n\t\t\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\t\t\tthumbnailsScope.thumbnails,\n\t\t\t\t\t\t\t\t\t\tR.mapWithIndex((thumbnailName, thumbnail) =>\n\t\t\t\t\t\t\t\t\t\t\tthumbnail.url\n\t\t\t\t\t\t\t\t\t\t\t\t? createRemoteFileNode({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\turl: removeURLParameter(thumbnail.url, \"auto\"),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpath: [...path, thumbnailName],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfield: thumbnail,\n\t\t\t\t\t\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t\t\t\t\t\t: RTE.right(null),\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\tR.sequence(RTE.ApplicativeSeq),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tRTE.map((scope) =>\n\t\t\t\t\t\t\t\t\tpipe(\n\t\t\t\t\t\t\t\t\t\tscope.thumbnails,\n\t\t\t\t\t\t\t\t\t\tR.mapWithIndex((key, value) => ({\n\t\t\t\t\t\t\t\t\t\t\t...value,\n\t\t\t\t\t\t\t\t\t\t\tlocalFile: scope.thumbnailFileNodes[key]?.id || null,\n\t\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tRTE.bind(\"fileNode\", (scope) => {\n\t\t\t\t\t\t\treturn scope.value.url\n\t\t\t\t\t\t\t\t? createRemoteFileNode({\n\t\t\t\t\t\t\t\t\t\turl: removeURLParameter(scope.value.url, \"auto\"),\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\tfield: scope.value,\n\t\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t\t: RTE.right(null);\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tRTE.map((scope) => ({\n\t\t\t\t\t\t\t...scope.value,\n\t\t\t\t\t\t\t...scope.thumbnails,\n\t\t\t\t\t\t\tlocalFile: scope.fileNode?.id || null,\n\t\t\t\t\t\t})),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Boolean:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Color:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Date:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.GeoPoint:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Number:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Select:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.StructuredText:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Text:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.Timestamp:\n\t\t\t\tcase prismicT.CustomTypeModelFieldType.UID:\n\t\t\t\tcase PrismicSpecialType.Unknown:\n\t\t\t\tdefault: {\n\t\t\t\t\treturn RTE.throwError(\n\t\t\t\t\t\tnew Error(\"Normalization not necessary for this value.\"),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\t// If a normalizer fails or no normalizer exists for the subtree, keep the\n\t\t// subtree as is.\n\t\tRTE.orElse(() => RTE.right(value)),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies, TypePathKind } from \"../types\";\nimport { normalizeDocumentSubtree } from \"./normalizeDocumentSubtree\";\n\n/**\n * Type guard to verify that the given value is a valid Prismic document.\n */\nconst documentRefinement = (\n\tvalue: unknown,\n): value is prismicT.PrismicDocument =>\n\ttypeof value === \"object\" &&\n\tvalue !== null &&\n\t!Array.isArray(value) &&\n\t\"id\" in value &&\n\t\"type\" in value;\n\n/**\n * Normalizes values of a Prismic document where necessary.\n *\n * @param doc - Prismic document to normalize.\n *\n * @returns Normalized Prismic document.\n * @see gatsby-source-prismic/lib/normalizeDocumentSubtree.ts\n */\nexport const normalizeDocument = (\n\tdoc: prismicT.PrismicDocument,\n): RTE.ReaderTaskEither<Dependencies, Error, prismicT.PrismicDocument> =>\n\tpipe(\n\t\tnormalizeDocumentSubtree(TypePathKind.CustomType, [doc.type], doc),\n\t\tRTE.chainW(\n\t\t\tRTE.fromPredicate(\n\t\t\t\tdocumentRefinement,\n\t\t\t\t() =>\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"Document shape is no longer a Document after normalization\",\n\t\t\t\t\t),\n\t\t\t),\n\t\t),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { normalizeDocument } from \"./normalizeDocument\";\n\n/**\n * Normalizes one or more documents.\n *\n * @see gatsby-source-prismic/lib/normalizeDocument.ts\n */\nexport const normalizeDocuments = flow(\n\tA.map(normalizeDocument),\n\tRTE.sequenceArray,\n);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Queries all documents from a Prismic repository using the environment's\n * configuration. The following fields from the environment's `pluginOptions` are used:\n *\n * - `pluginOptions.releaseID`: Prismic Release ID from which to fetch documents.\n *   If not provided, the master ref is used.\n * - `pluginOptions.graphQuery`: GraphQuery to fetch nested data.\n * - `pluginOptions.fetchLinks`: List of document link fields to fetch.\n * - `pluginOptions.lang`: Language of documents to fetch. If not provided, all\n *   languages are fetched.\n *\n * @returns List of Prismic documents.\n */\nexport const queryAllDocuments: RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tprismicT.PrismicDocument[]\n> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((env) =>\n\t\tRTE.fromTask(() =>\n\t\t\tenv.prismicClient.dangerouslyGetAll({\n\t\t\t\tpageSize: env.pluginOptions.pageSize,\n\t\t\t}),\n\t\t),\n\t),\n);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe, constVoid } from \"fp-ts/function\";\n\nimport { Dependencies, Mutable } from \"../types\";\n\nimport { createGloballyUniqueNodes } from \"./createGloballyUniqueNodes\";\nimport { normalizeDocuments } from \"./normalizeDocuments\";\nimport { queryAllDocuments } from \"./queryAllDocuments\";\n\n/**\n * Queries all documents from the environment's Prismic repository and creates\n * nodes for each document.\n */\nexport const sourceNodesForAllDocuments: RTE.ReaderTaskEither<\n\tDependencies,\n\tError,\n\tvoid\n> = pipe(\n\tqueryAllDocuments,\n\tRTE.chainW(normalizeDocuments),\n\tRTE.chainW((docs) => createGloballyUniqueNodes(docs as Mutable<typeof docs>)),\n\tRTE.map(constVoid),\n);\n","/**\n * Determines if a given URL is a valid Prismic URL.\n *\n * @param url - URL to test.\n */\nexport const isPrismicURL = (url: string): boolean =>\n\t/^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)\\/api\\/?/.test(url);\n","import { isPrismicURL } from \"./isPrismicURL\";\n\nimport { PrismicWebhookBody } from \"../types\";\n\n/**\n * Determines if some piece of data is a Prismic webhook body.\n *\n * @param webhookBody - Piece of data to test.\n */\nexport const isPrismicWebhookBody = (\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\twebhookBody: any,\n): webhookBody is PrismicWebhookBody =>\n\ttypeof webhookBody === \"object\" &&\n\ttypeof webhookBody.apiUrl === \"string\" &&\n\tisPrismicURL(webhookBody.apiUrl);\n","import { isPrismicWebhookBody } from \"./isPrismicWebhookBody\";\n\nimport { PrismicWebhookBodyApiUpdate, PrismicWebhookType } from \"../types\";\n\n/**\n * Determines if some piece of data is a Prismic `api-update` webhook body.\n *\n * @param webhookBody - Piece of data to test.\n */\nexport const isPrismicWebhookBodyApiUpdate = (\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\twebhookBody: any,\n): webhookBody is PrismicWebhookBodyApiUpdate =>\n\tisPrismicWebhookBody(webhookBody) &&\n\twebhookBody.type === PrismicWebhookType.APIUpdate;\n","import { isPrismicWebhookBody } from \"./isPrismicWebhookBody\";\n\nimport { PrismicWebhookBody } from \"../types\";\n\n/**\n * Determines if some piece of data is a Prismic webhook body for a given repository.\n *\n * @param webhookBody - Piece of data to test.\n * @param repositoryName - Name of the repository to check the webhook body against.\n */\nexport const isPrismicWebhookBodyForRepository =\n\t(repositoryName: string) =>\n\t(\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\t\twebhookBody: any,\n\t): webhookBody is PrismicWebhookBody =>\n\t\tisPrismicWebhookBody(webhookBody) && webhookBody.domain === repositoryName;\n","import { isPrismicWebhookBody } from \"./isPrismicWebhookBody\";\n\nimport { PrismicWebhookBodyTestTrigger, PrismicWebhookType } from \"../types\";\n\n/**\n * Determines if some piece of data is a Prismic `api-update` webhook body.\n *\n * @param webhookBody - Piece of data to test.\n */\nexport const isPrismicWebhookBodyTestTrigger = (\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\twebhookBody: any,\n): webhookBody is PrismicWebhookBodyTestTrigger =>\n\tisPrismicWebhookBody(webhookBody) &&\n\twebhookBody.type === PrismicWebhookType.TestTrigger;\n","import { PrismicWebhookBody } from \"../types\";\n\n/**\n * Determines if a webhook body's secret matches a given secret. If no secret is\n * given, any webhook body secret is valid, including the absence of a webhook\n * body secret.\n *\n * @param webhookBody - Webhook body optionally containing a secret.\n * @param secret - Secret to test against the webhook body.\n *\n * @returns `true` if the secret is valid, `false` otherwise.\n */\nexport const isValidWebhookSecret =\n\t(secret?: string) =>\n\t(webhookBody: PrismicWebhookBody): boolean =>\n\t\tsecret ? webhookBody.secret === secret : true;\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\nimport { REPORTER_TEMPLATE } from \"../constants\";\nimport { sprintf } from \"./sprintf\";\n\n/**\n * Reports a piece of text at the \"warning\" importance level using the\n * environment's `reportWarning` function.\n *\n * @param text - Text to report.\n */\nexport const reportWarning = (\n\ttext: string,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) =>\n\t\tpipe(\n\t\t\tsprintf(REPORTER_TEMPLATE, deps.pluginOptions.repositoryName, text),\n\t\t\tdeps.reportWarning,\n\t\t),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Returns a node using the environment's `getNode` function.\n *\n * @param nodeId - ID of the node to return.\n */\nexport const getNode = (\n\tnodeId: string,\n): RTE.ReaderTaskEither<Dependencies, never, gatsby.Node | undefined> =>\n\tRTE.asks((deps) => deps.getNode(nodeId));\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { getNode } from \"./getNode\";\n\n/**\n * Returns one or more nodes.\n *\n * @see gatsby-source-prismic/lib/getNode.ts\n */\nexport const getNodes = flow(A.map(getNode), RTE.sequenceArray);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Deletes a node using the environment's `deleteNode` function.\n *\n * @param node - Node to delete.\n */\nexport const deleteNode = (\n\tnode: gatsby.Node,\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tRTE.asks((deps) => deps.deleteNode(node));\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { deleteNode } from \"./deleteNode\";\n\n/**\n * Deletes one or more nodes.\n *\n * @see gatsby-source-prismic/lib/deleteNode.ts\n */\nexport const deleteNodes = flow(A.map(deleteNode), RTE.sequenceArray);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe, constVoid } from \"fp-ts/function\";\n\nimport { Dependencies, Mutable } from \"../types\";\n\nimport { getNodes } from \"./getNodes\";\nimport { deleteNodes } from \"./deleteNodes\";\n\n/**\n * Deletes nodes for a given set of Prismic document IDs. Note that these are\n * Prismic document IDs, not Gatsby Node IDs.\n *\n * @param documentIds - List of Prismic document IDs used to find nodes to delete.\n */\nexport const deleteNodesForDocumentIds = (\n\tdocumentIds: string[],\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\tdocumentIds,\n\t\t\t\tA.map(deps.nodeHelpers.createNodeId),\n\t\t\t\tgetNodes,\n\t\t\t\tRTE.map((nodes) =>\n\t\t\t\t\tpipe(\n\t\t\t\t\t\tnodes as Mutable<typeof nodes>,\n\t\t\t\t\t\tA.filter((node): node is NonNullable<typeof node> => node != null),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tRTE.chain((nodes) => deleteNodes(nodes)),\n\t\t\t\tRTE.map(constVoid),\n\t\t\t),\n\t\t),\n\t);\n","import * as prismicT from \"@prismicio/types\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Queries a list of documents by their IDs from a Prismic repository using the\n * environment's configuration. The following fields from the environment's\n * `pluginOptions` are used, in addition to those used in `createClient`:\n *\n * - `pluginOptions.releaseID`: Prismic Release ID from which to fetch documents.\n *   If not provided, the master ref is used.\n * - `pluginOptions.fetchLinks`: List of document link fields to fetch.\n * - `pluginOptions.lang`: Language of documents to fetch. If not provided, all\n *   languages are fetched.\n *\n * @returns List of Prismic documents.\n */\nexport const queryDocumentsByIds = (\n\tids: string[],\n): RTE.ReaderTaskEither<Dependencies, Error, prismicT.PrismicDocument[]> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((env) =>\n\t\t\tRTE.fromTask(() =>\n\t\t\t\tenv.prismicClient.getAllByIDs(ids, {\n\t\t\t\t\tpageSize: env.pluginOptions.pageSize,\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { constVoid, pipe } from \"fp-ts/function\";\n\nimport { Dependencies, Mutable } from \"../types\";\n\nimport { createGloballyUniqueNodes } from \"./createGloballyUniqueNodes\";\nimport { normalizeDocuments } from \"./normalizeDocuments\";\nimport { queryDocumentsByIds } from \"./queryDocumentsByIds\";\n\n/**\n * Queries documents in a list of Prismic document IDs from the environment's\n * Prismic repository and creates nodes for each document.\n *\n * @param documentIds - List of Prismic document IDs to query and with which to\n *   create nodes.\n */\nexport const sourceNodesForDocumentIds = (\n\tdocumentIds: string[],\n): RTE.ReaderTaskEither<Dependencies, Error, void> =>\n\tpipe(\n\t\tqueryDocumentsByIds(documentIds),\n\t\tRTE.chainW(normalizeDocuments),\n\t\tRTE.chainW((docs) =>\n\t\t\tcreateGloballyUniqueNodes(docs as Mutable<typeof docs>),\n\t\t),\n\t\tRTE.map(constVoid),\n\t);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\n\nimport { Dependencies } from \"../types\";\n\n/**\n * Returns all nodes using the environment's `getNodes` function.\n */\nexport const getAllNodes = (): RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tgatsby.Node[]\n> => RTE.asks((deps) => deps.getNodes());\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { flow } from \"fp-ts/function\";\n\nimport { touchNode } from \"./touchNode\";\n\n/**\n * Touches one or more nodes.\n *\n * @see gatsby-source-prismic/lib/touchNode.ts\n */\nexport const touchNodes = flow(A.map(touchNode), RTE.sequenceArray);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport { pipe, constVoid } from \"fp-ts/function\";\n\nimport { Dependencies, PrismicAPIDocumentNode } from \"../types\";\n\nimport { getAllNodes } from \"./getAllNodes\";\nimport { touchNodes } from \"./touchNodes\";\nimport { PLUGIN_NAME } from \"../constants\";\n\ntype TouchAllNodesConfig = {\n\texceptPrismicIds: string[];\n};\n\n/**\n * Touches all gatsby-source-prismic nodes using the environment's `getAllNodes`\n * and `touchNodes` functions.\n */\nexport const touchAllNodes = (\n\tconfig: TouchAllNodesConfig = { exceptPrismicIds: [] },\n): RTE.ReaderTaskEither<Dependencies, never, void> =>\n\tpipe(\n\t\tgetAllNodes(),\n\t\tRTE.map(\n\t\t\tA.filter(\n\t\t\t\t(node): node is PrismicAPIDocumentNode =>\n\t\t\t\t\tnode.internal.owner === PLUGIN_NAME,\n\t\t\t),\n\t\t),\n\t\tRTE.map(\n\t\t\tA.filter((node) => !config.exceptPrismicIds.includes(node.prismicId)),\n\t\t),\n\t\tRTE.chain(touchNodes),\n\t\tRTE.map(constVoid),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as A from \"fp-ts/Array\";\nimport * as s from \"fp-ts/string\";\nimport { pipe, constVoid } from \"fp-ts/function\";\n\nimport { deleteNodesForDocumentIds } from \"./lib/deleteNodesForDocumentIds\";\nimport { queryDocumentsByIds } from \"./lib/queryDocumentsByIds\";\nimport { reportInfo } from \"./lib/reportInfo\";\nimport { sourceNodesForDocumentIds } from \"./lib/sourceNodesForDocumentIds\";\nimport { touchAllNodes } from \"./lib/touchAllNodes\";\n\nimport { Dependencies, PrismicWebhookBodyApiUpdate } from \"./types\";\n\n/**\n * Extract all document IDs from a Prismic `api-update` webhook body. All\n * document IDs, including deleted documents, are returned in the same list.\n */\nconst extractApiUpdateWebhookBodyDocumentIds = (\n\twebhookBody: PrismicWebhookBodyApiUpdate,\n): RTE.ReaderTaskEither<Dependencies, never, string[]> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.bindW(\"documentIds\", () => RTE.right(webhookBody.documents)),\n\t\tRTE.bindW(\"releaseDocumentIds\", (scope) =>\n\t\t\tpipe(\n\t\t\t\t[\n\t\t\t\t\t...(webhookBody.releases.update || []),\n\t\t\t\t\t...(webhookBody.releases.addition || []),\n\t\t\t\t\t...(webhookBody.releases.deletion || []),\n\t\t\t\t],\n\t\t\t\tA.filter((payload) => payload.id === scope.pluginOptions.releaseID),\n\t\t\t\tA.chain((payload) => payload.documents),\n\t\t\t\tRTE.right,\n\t\t\t),\n\t\t),\n\t\tRTE.map((scope) => [\n\t\t\t...new Set([...scope.documentIds, ...scope.releaseDocumentIds]),\n\t\t]),\n\t);\n\n/**\n * To be executed in the `sourceNodes` API when a Prismic `api-update` webhook\n * is received.\n *\n * This handler is implemented specifically for Gatsby Preview support.\n *\n * This handler performs delta changes to documents that have been updated or deleted.\n *\n * - UPDATED documents: Nodes are updated in the Gatsby data layer.\n * - DELETED documents: Nodes are deleted from the Gatsby data layer.\n *\n * After the handler is complete, the Gatsby data layer should be identical to\n * one that just performed a fresh bootstrap.\n */\nexport const onWebhookApiUpdate = (\n\twebhookBody: PrismicWebhookBodyApiUpdate,\n): RTE.ReaderTaskEither<Dependencies, Error, void> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chainFirst(() =>\n\t\t\treportInfo(\"Received API update webhook. Processing changes.\"),\n\t\t),\n\t\tRTE.bind(\"documentIds\", () =>\n\t\t\textractApiUpdateWebhookBodyDocumentIds(webhookBody),\n\t\t),\n\t\tRTE.bind(\"documentsToUpdate\", (scope) =>\n\t\t\tqueryDocumentsByIds(scope.documentIds),\n\t\t),\n\t\tRTE.bind(\"documentIdsToUpdate\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.documentsToUpdate,\n\t\t\t\tA.map((document) => document.id),\n\t\t\t\t(ids) => RTE.right(ids),\n\t\t\t),\n\t\t),\n\t\t// Documents that have been deleted are included in the `documents` field,\n\t\t// but they are not marked as deleted. They appear adjacent to documents\n\t\t// that still exist but have only been updated.\n\t\t//\n\t\t// To check if the document was deleted, we query for all documents in the\n\t\t// `documents` field and compare the result to that list. Documents that\n\t\t// have been deleted will not be returned from the query.\n\t\tRTE.bind(\"documentIdsToDelete\", (scope) =>\n\t\t\tpipe(\n\t\t\t\tscope.documentIds,\n\t\t\t\tA.difference(s.Eq)(scope.documentIdsToUpdate),\n\t\t\t\t(ids) => RTE.right(ids),\n\t\t\t),\n\t\t),\n\t\tRTE.chainFirstW((scope) =>\n\t\t\treportInfo(\n\t\t\t\t`Adding or updating the following Prismic documents: [${scope.documentIdsToUpdate\n\t\t\t\t\t.map((id) => `\"${id}\"`)\n\t\t\t\t\t.join(\", \")}]`,\n\t\t\t),\n\t\t),\n\t\tRTE.chainFirstW((scope) =>\n\t\t\treportInfo(\n\t\t\t\t`Deleting the following Prismic documents: [${scope.documentIdsToDelete\n\t\t\t\t\t.map((id) => `\"${id}\"`)\n\t\t\t\t\t.join(\", \")}]`,\n\t\t\t),\n\t\t),\n\t\tRTE.chainFirstW((scope) =>\n\t\t\tdeleteNodesForDocumentIds(scope.documentIdsToDelete),\n\t\t),\n\t\tRTE.chainFirstW((scope) =>\n\t\t\tsourceNodesForDocumentIds(scope.documentIdsToUpdate),\n\t\t),\n\t\tRTE.chainFirstW((scope) =>\n\t\t\ttouchAllNodes({\n\t\t\t\texceptPrismicIds: scope.documentIdsToDelete,\n\t\t\t}),\n\t\t),\n\t\tRTE.map(constVoid),\n\t);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { reportInfo } from \"./lib/reportInfo\";\nimport { touchAllNodes } from \"./lib/touchAllNodes\";\n\nimport { WEBHOOK_TEST_TRIGGER_SUCCESS_MSG } from \"./constants\";\nimport { Dependencies } from \"./types\";\n\n/**\n * To be executed in the `sourceNodes` API when a Prismic `test-trigger` webhook\n * is received.\n *\n * This handler simply prints a success string to the console to signify receipt.\n */\nexport const onWebhookTestTrigger: RTE.ReaderTaskEither<\n\tDependencies,\n\tnever,\n\tvoid\n> = pipe(\n\treportInfo(WEBHOOK_TEST_TRIGGER_SUCCESS_MSG),\n\tRTE.chainFirstW(() => touchAllNodes()),\n);\n","import * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as O from \"fp-ts/Option\";\nimport { pipe } from \"fp-ts/function\";\n\nimport { isPrismicWebhookBodyApiUpdate } from \"./lib/isPrismicWebhookBodyApiUpdate\";\nimport { isPrismicWebhookBodyForRepository } from \"./lib/isPrismicWebhookBodyForRepository\";\nimport { isPrismicWebhookBodyTestTrigger } from \"./lib/isPrismicWebhookBodyTestTrigger\";\nimport { isValidWebhookSecret } from \"./lib/isValidWebhookSecret\";\nimport { reportWarning } from \"./lib/reportWarning\";\n\nimport { Dependencies, PrismicWebhookBody } from \"./types\";\nimport { WEBHOOK_SECRET_MISMATCH_MSG } from \"./constants\";\nimport { onWebhookApiUpdate } from \"./on-webhook-api-update\";\nimport { onWebhookTestTrigger } from \"./on-webhook-test-trigger\";\n\n/**\n * Calls the appropriate webhook handler depending on its contents.\n *\n * If the webhook is not intended for this plugin, the webhook is ignored.\n */\nconst onPrismicWebhook = (\n\twebhookBody: PrismicWebhookBody,\n): RTE.ReaderTaskEither<Dependencies, Error, void> =>\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chain((deps) =>\n\t\t\tpipe(\n\t\t\t\twebhookBody,\n\t\t\t\tO.fromPredicate(isValidWebhookSecret(deps.pluginOptions.webhookSecret)),\n\t\t\t\tO.fold(\n\t\t\t\t\t() => reportWarning(WEBHOOK_SECRET_MISMATCH_MSG),\n\t\t\t\t\t(webhookBody) => {\n\t\t\t\t\t\tif (isPrismicWebhookBodyApiUpdate(webhookBody)) {\n\t\t\t\t\t\t\treturn onWebhookApiUpdate(webhookBody);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isPrismicWebhookBodyTestTrigger(webhookBody)) {\n\t\t\t\t\t\t\treturn onWebhookTestTrigger;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This webhook is unsupported or does not pertain to this plugin.\n\t\t\t\t\t\treturn RTE.right(void 0);\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t);\n\n/**\n * To be executed in the `sourceNodes` stage when a webhook is received.\n *\n * If the webhook is from Prismic, and the webhook's secret matches the secret\n * defined in the environment's plugin options, a handler appropriate to the\n * webhook's type is called.\n *\n * All nodes, regardless of the webhook' source or contents, are touched to\n * prevent garbage collection.\n */\nexport const onWebhook: RTE.ReaderTaskEither<Dependencies, Error, void> = pipe(\n\tRTE.ask<Dependencies>(),\n\tRTE.chain((deps) =>\n\t\tpipe(\n\t\t\tdeps.webhookBody,\n\t\t\tO.fromPredicate(\n\t\t\t\tisPrismicWebhookBodyForRepository(deps.pluginOptions.repositoryName),\n\t\t\t),\n\t\t\tO.fold(() => RTE.right(void 0), onPrismicWebhook),\n\t\t),\n\t),\n);\n","import * as gatsby from \"gatsby\";\nimport * as RTE from \"fp-ts/ReaderTaskEither\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport * as T from \"fp-ts/Task\";\nimport { constVoid, pipe } from \"fp-ts/function\";\n\nimport { preparePluginOptions } from \"./lib/preparePluginOptions\";\nimport { sourceNodesForAllDocuments } from \"./lib/sourceNodesForAllDocuments\";\nimport { throwError } from \"./lib/throwError\";\n\nimport { Dependencies, UnpreparedPluginOptions } from \"./types\";\nimport { buildDependencies } from \"./buildDependencies\";\nimport { onWebhook } from \"./on-webhook\";\n\n/**\n * To be executed in the `sourceNodes` API.\n */\nconst sourceNodesProgram: RTE.ReaderTaskEither<Dependencies, Error, void> =\n\tpipe(\n\t\tRTE.ask<Dependencies>(),\n\t\tRTE.chainW(\n\t\t\tRTE.fromPredicate(\n\t\t\t\t(deps) =>\n\t\t\t\t\tBoolean(\n\t\t\t\t\t\tdeps.webhookBody && JSON.stringify(deps.webhookBody) !== \"{}\",\n\t\t\t\t\t),\n\t\t\t\tconstVoid,\n\t\t\t),\n\t\t),\n\t\tRTE.fold(\n\t\t\t() => sourceNodesForAllDocuments,\n\t\t\t() => onWebhook,\n\t\t),\n\t);\n\n/**\n * Extension point to tell plugins to source nodes.\n *\n * @see https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#sourceNodes\n */\nexport const sourceNodes: NonNullable<gatsby.GatsbyNode[\"sourceNodes\"]> =\n\tasync (\n\t\tgatsbyContext: gatsby.SourceNodesArgs,\n\t\tunpreparedPluginOptions: UnpreparedPluginOptions,\n\t) => {\n\t\tconst pluginOptions = await preparePluginOptions(unpreparedPluginOptions);\n\t\tconst dependencies = await buildDependencies(gatsbyContext, pluginOptions);\n\n\t\treturn await pipe(\n\t\t\tsourceNodesProgram(dependencies),\n\t\t\tTE.fold(throwError, () => T.of(void 0)),\n\t\t)();\n\t};\n"],"names":["RTE","pipe","A","flow","R","S","O","constNull","imgixGatsby","ReadonlyA","identity","prismicT","E","struct","prismicH","I","constVoid","prismic","gatsbyFs","nodeFetch","prismicCustomTypes","imgixGatsbyHelpers","normalizers.isDocument","normalizers.document","normalizers.isDocumentDataField","normalizers.documentData","normalizers.isGroupField","normalizers.group","normalizers.isSlices","normalizers.slices","normalizers.isSlice","normalizers.slice","normalizers.isLinkField","normalizers.link","normalizers.isImageField","normalizers.image","normalizers.isStructuredTextField","normalizers.structuredText","nodeHelpers","createNodeHelpers","TE","T","fetch","documentRefinement","s"],"mappings":"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"}